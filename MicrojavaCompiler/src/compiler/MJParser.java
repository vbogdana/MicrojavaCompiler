
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Jan 31 15:32:41 CET 2016
//----------------------------------------------------

package compiler;

import java_cup.runtime.*;
import java.util.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.DumpSymbolTableVisitor;
import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Jan 31 15:32:41 CET 2016
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\216\000\002\002\010\000\002\002\004\000\002\053" +
    "\003\000\002\003\004\000\002\003\002\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\047\004\000" +
    "\002\047\002\000\002\017\004\000\002\017\002\000\002" +
    "\056\003\000\002\056\003\000\002\056\003\000\002\056" +
    "\003\000\002\010\003\000\002\057\003\000\002\005\006" +
    "\000\002\005\006\000\002\005\005\000\002\006\005\000" +
    "\002\006\005\000\002\006\003\000\002\007\005\000\002" +
    "\007\005\000\002\011\005\000\002\011\005\000\002\012" +
    "\005\000\002\012\005\000\002\012\003\000\002\013\004" +
    "\000\002\077\002\000\002\050\006\000\002\050\005\000" +
    "\002\050\004\000\002\051\005\000\002\051\003\000\002" +
    "\052\004\000\002\072\004\000\002\072\002\000\002\100" +
    "\002\000\002\101\002\000\002\102\002\000\002\014\014" +
    "\000\002\015\004\000\002\015\004\000\002\015\002\000" +
    "\002\016\005\000\002\016\002\000\002\103\002\000\002" +
    "\020\014\000\002\060\003\000\002\060\003\000\002\021" +
    "\003\000\002\021\002\000\002\022\005\000\002\022\005" +
    "\000\002\022\003\000\002\023\005\000\002\023\004\000" +
    "\002\024\004\000\002\024\002\000\002\025\003\000\002" +
    "\025\003\000\002\027\003\000\002\027\003\000\002\026" +
    "\003\000\002\026\003\000\002\026\003\000\002\026\003" +
    "\000\002\026\003\000\002\026\003\000\002\026\003\000" +
    "\002\026\005\000\002\037\003\000\002\037\003\000\002" +
    "\037\003\000\002\073\006\000\002\073\006\000\002\074" +
    "\005\000\002\075\003\000\002\075\003\000\002\076\004" +
    "\000\002\104\002\000\002\064\007\000\002\064\005\000" +
    "\002\064\006\000\002\065\003\000\002\065\005\000\002" +
    "\030\011\000\002\031\007\000\002\031\011\000\002\032" +
    "\003\000\002\033\007\000\002\034\007\000\002\036\003" +
    "\000\002\035\004\000\002\067\003\000\002\067\003\000" +
    "\002\066\005\000\002\066\003\000\002\070\003\000\002" +
    "\070\005\000\002\071\003\000\002\071\005\000\002\040" +
    "\004\000\002\040\005\000\002\041\007\000\002\042\010" +
    "\000\002\043\004\000\002\043\002\000\002\054\003\000" +
    "\002\055\005\000\002\055\006\000\002\055\003\000\002" +
    "\055\006\000\002\062\003\000\002\062\004\000\002\062" +
    "\005\000\002\063\003\000\002\063\005\000\002\061\003" +
    "\000\002\061\007\000\002\061\004\000\002\061\003\000" +
    "\002\061\003\000\002\061\003\000\002\061\003\000\002" +
    "\061\003\000\002\061\005\000\002\044\003\000\002\044" +
    "\003\000\002\044\003\000\002\044\003\000\002\044\003" +
    "\000\002\044\003\000\002\045\003\000\002\045\003\000" +
    "\002\046\003\000\002\046\003\000\002\046\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\350\000\004\004\005\001\002\000\004\002\352\001" +
    "\002\000\004\021\007\001\002\000\012\006\ufffd\010\ufffd" +
    "\021\ufffd\055\ufffd\001\002\000\012\006\uffff\010\uffff\021" +
    "\uffff\055\uffff\001\002\000\012\006\021\010\022\021\013" +
    "\055\012\001\002\000\006\003\ufff1\021\ufff1\001\002\000" +
    "\010\016\ufff6\021\ufff6\056\ufff6\001\002\000\054\003\ufff0" +
    "\021\ufff0\026\ufff0\027\ufff0\030\ufff0\031\ufff0\032\ufff0\033" +
    "\ufff0\034\ufff0\035\ufff0\036\ufff0\037\ufff0\040\ufff0\041\ufff0" +
    "\042\ufff0\046\ufff0\047\ufff0\052\ufff0\053\ufff0\054\ufff0\055" +
    "\ufff0\001\002\000\006\003\335\021\337\001\002\000\012" +
    "\006\ufffb\010\ufffb\021\ufffb\055\ufffb\001\002\000\012\006" +
    "\ufffa\010\ufffa\021\ufffa\055\ufffa\001\002\000\012\006\ufffe" +
    "\010\ufffe\021\ufffe\055\ufffe\001\002\000\012\006\ufffc\010" +
    "\ufffc\021\ufffc\055\ufffc\001\002\000\004\021\047\001\002" +
    "\000\006\003\023\021\013\001\002\000\004\046\046\001" +
    "\002\000\006\003\025\021\030\001\002\000\006\046\044" +
    "\047\043\001\002\000\006\046\uffea\047\uffea\001\002\000" +
    "\006\046\041\047\040\001\002\000\004\043\031\001\002" +
    "\000\014\003\033\022\034\023\037\024\036\025\032\001" +
    "\002\000\006\046\ufff2\047\ufff2\001\002\000\006\046\uffe8" +
    "\047\uffe8\001\002\000\006\046\ufff5\047\ufff5\001\002\000" +
    "\006\046\uffe9\047\uffe9\001\002\000\006\046\ufff3\047\ufff3" +
    "\001\002\000\006\046\ufff4\047\ufff4\001\002\000\004\021" +
    "\030\001\002\000\012\006\uffef\010\uffef\021\uffef\055\uffef" +
    "\001\002\000\006\046\uffec\047\uffec\001\002\000\004\021" +
    "\030\001\002\000\012\006\uffee\010\uffee\021\uffee\055\uffee" +
    "\001\002\000\006\046\uffeb\047\uffeb\001\002\000\012\006" +
    "\uffed\010\uffed\021\uffed\055\uffed\001\002\000\006\020\uffd8" +
    "\055\uffd8\001\002\000\006\020\051\055\uffd2\001\002\000" +
    "\006\003\334\021\013\001\002\000\004\055\053\001\002" +
    "\000\010\021\uffd7\055\uffd7\056\uffd7\001\002\000\010\021" +
    "\ufff8\055\ufff8\056\ufff8\001\002\000\010\021\013\055\uffd6" +
    "\056\uffd6\001\002\000\006\055\076\056\uffd0\001\002\000" +
    "\010\021\ufff9\055\ufff9\056\ufff9\001\002\000\006\003\062" +
    "\021\uffe1\001\002\000\004\021\065\001\002\000\012\021" +
    "\uffde\046\063\055\uffde\056\uffde\001\002\000\010\021\uffdf" +
    "\055\uffdf\056\uffdf\001\002\000\006\046\073\047\072\001" +
    "\002\000\010\046\uffd9\047\uffd9\053\070\001\002\000\006" +
    "\046\uffdc\047\uffdc\001\002\000\006\046\uffdb\047\uffdb\001" +
    "\002\000\004\054\071\001\002\000\010\046\uffda\047\uffda" +
    "\052\uffda\001\002\000\004\021\065\001\002\000\010\021" +
    "\uffe0\055\uffe0\056\uffe0\001\002\000\006\046\uffdd\047\uffdd" +
    "\001\002\000\004\056\332\001\002\000\010\016\ufff6\021" +
    "\ufff6\056\ufff6\001\002\000\010\016\103\021\013\056\101" +
    "\001\002\000\004\021\uffcd\001\002\000\004\056\uffd1\001" +
    "\002\000\010\016\ufff7\021\ufff7\056\ufff7\001\002\000\004" +
    "\021\uffcc\001\002\000\004\021\105\001\002\000\004\051" +
    "\uffcf\001\002\000\004\051\107\001\002\000\010\003\111" +
    "\021\013\052\uffca\001\002\000\006\003\327\021\330\001" +
    "\002\000\004\047\325\001\002\000\004\052\117\001\002" +
    "\000\006\047\115\052\uffcb\001\002\000\006\047\uffc7\052" +
    "\uffc7\001\002\000\004\021\013\001\002\000\006\047\uffc9" +
    "\052\uffc9\001\002\000\006\021\ufff8\055\ufff8\001\002\000" +
    "\006\021\013\055\121\001\002\000\024\005\uffc3\011\uffc3" +
    "\013\uffc3\014\uffc3\015\uffc3\017\uffc3\021\uffc3\055\uffc3\056" +
    "\uffc3\001\002\000\024\005\146\011\140\013\150\014\124" +
    "\015\136\017\133\021\127\055\141\056\131\001\002\000" +
    "\012\043\315\044\316\045\317\051\210\001\002\000\004" +
    "\051\310\001\002\000\026\005\uffbd\007\uffbd\011\uffbd\013" +
    "\uffbd\014\uffbd\015\uffbd\017\uffbd\021\uffbd\055\uffbd\056\uffbd" +
    "\001\002\000\026\005\uffb6\007\uffb6\011\uffb6\013\uffb6\014" +
    "\uffb6\015\uffb6\017\uffb6\021\uffb6\055\uffb6\056\uffb6\001\002" +
    "\000\060\026\uff8e\027\uff8e\030\uff8e\031\uff8e\032\uff8e\033" +
    "\uff8e\034\uff8e\035\uff8e\036\uff8e\037\uff8e\040\uff8e\041\uff8e" +
    "\042\uff8e\043\uff8e\044\uff8e\045\uff8e\046\uff8e\047\uff8e\050" +
    "\uff8e\051\uff8e\052\uff8e\053\uff8e\054\uff8e\001\002\000\026" +
    "\005\uffbe\007\uffbe\011\uffbe\013\uffbe\014\uffbe\015\uffbe\017" +
    "\uffbe\021\uffbe\055\uffbe\056\uffbe\001\002\000\010\016\uffce" +
    "\021\uffce\056\uffce\001\002\000\026\005\uffba\007\uffba\011" +
    "\uffba\013\uffba\014\uffba\015\uffba\017\uffba\021\uffba\055\uffba" +
    "\056\uffba\001\002\000\004\051\uffa1\001\002\000\026\005" +
    "\uffb8\007\uffb8\011\uffb8\013\uffb8\014\uffb8\015\uffb8\017\uffb8" +
    "\021\uffb8\055\uffb8\056\uffb8\001\002\000\024\005\uffc0\011" +
    "\uffc0\013\uffc0\014\uffc0\015\uffc0\017\uffc0\021\uffc0\055\uffc0" +
    "\056\uffc0\001\002\000\024\012\164\021\127\022\167\023" +
    "\174\024\162\025\170\027\161\046\306\051\173\001\002" +
    "\000\004\046\304\001\002\000\004\051\uffa4\001\002\000" +
    "\024\005\uffc3\011\uffc3\013\uffc3\014\uffc3\015\uffc3\017\uffc3" +
    "\021\uffc3\055\uffc3\056\uffc3\001\002\000\004\051\275\001" +
    "\002\000\026\005\uffb4\007\uffb4\011\uffb4\013\uffb4\014\uffb4" +
    "\015\uffb4\017\uffb4\021\uffb4\055\uffb4\056\uffb4\001\002\000" +
    "\060\026\uff91\027\uff91\030\uff91\031\uff91\032\uff91\033\uff91" +
    "\034\uff91\035\uff91\036\uff91\037\uff91\040\uff91\041\uff91\042" +
    "\uff91\043\uff91\044\uff91\045\uff91\046\uff91\047\uff91\050\266" +
    "\051\uff91\052\uff91\053\267\054\uff91\001\002\000\004\051" +
    "\235\001\002\000\004\046\234\001\002\000\024\005\uffc1" +
    "\011\uffc1\013\uffc1\014\uffc1\015\uffc1\017\uffc1\021\uffc1\055" +
    "\uffc1\056\uffc1\001\002\000\004\051\160\001\002\000\024" +
    "\005\uffc4\011\uffc4\013\uffc4\014\uffc4\015\uffc4\017\uffc4\021" +
    "\uffc4\055\uffc4\056\uffc4\001\002\000\026\005\uffb9\007\uffb9" +
    "\011\uffb9\013\uffb9\014\uffb9\015\uffb9\017\uffb9\021\uffb9\055" +
    "\uffb9\056\uffb9\001\002\000\026\005\uffb5\007\uffb5\011\uffb5" +
    "\013\uffb5\014\uffb5\015\uffb5\017\uffb5\021\uffb5\055\uffb5\056" +
    "\uffb5\001\002\000\024\005\uffbf\011\uffbf\013\uffbf\014\uffbf" +
    "\015\uffbf\017\uffbf\021\uffbf\055\uffbf\056\uffbf\001\002\000" +
    "\026\005\uffbc\007\uffbc\011\uffbc\013\uffbc\014\uffbc\015\uffbc" +
    "\017\uffbc\021\uffbc\055\uffbc\056\uffbc\001\002\000\024\005" +
    "\uffc2\011\uffc2\013\uffc2\014\uffc2\015\uffc2\017\uffc2\021\uffc2" +
    "\055\uffc2\056\uffc2\001\002\000\026\005\uffbb\007\uffbb\011" +
    "\uffbb\013\uffbb\014\uffbb\015\uffbb\017\uffbb\021\uffbb\055\uffbb" +
    "\056\uffbb\001\002\000\022\012\164\021\127\022\167\023" +
    "\174\024\162\025\170\027\161\051\173\001\002\000\020" +
    "\012\164\021\127\022\167\023\174\024\162\025\170\051" +
    "\173\001\002\000\044\026\uff80\027\uff80\030\uff80\031\uff80" +
    "\032\uff80\033\uff80\034\uff80\035\uff80\036\uff80\037\uff80\040" +
    "\uff80\041\uff80\042\uff80\046\uff80\047\uff80\052\uff80\054\uff80" +
    "\001\002\000\012\026\177\027\200\047\226\052\uff92\001" +
    "\002\000\004\021\013\001\002\000\044\026\uff87\027\uff87" +
    "\030\uff87\031\uff87\032\uff87\033\uff87\034\uff87\035\uff87\036" +
    "\uff87\037\uff87\040\uff87\041\uff87\042\uff87\046\uff87\047\uff87" +
    "\052\uff87\054\uff87\001\002\000\046\026\uff84\027\uff84\030" +
    "\uff84\031\uff84\032\uff84\033\uff84\034\uff84\035\uff84\036\uff84" +
    "\037\uff84\040\uff84\041\uff84\042\uff84\046\uff84\047\uff84\051" +
    "\210\052\uff84\054\uff84\001\002\000\044\026\uff83\027\uff83" +
    "\030\uff83\031\uff83\032\uff83\033\uff83\034\uff83\035\uff83\036" +
    "\uff83\037\uff83\040\uff83\041\uff83\042\uff83\046\uff83\047\uff83" +
    "\052\uff83\054\uff83\001\002\000\044\026\uff81\027\uff81\030" +
    "\uff81\031\uff81\032\uff81\033\uff81\034\uff81\035\uff81\036\uff81" +
    "\037\uff81\040\uff81\041\uff81\042\uff81\046\uff81\047\uff81\052" +
    "\uff81\054\uff81\001\002\000\044\026\uff8c\027\uff8c\030\204" +
    "\031\205\032\203\033\uff8c\034\uff8c\035\uff8c\036\uff8c\037" +
    "\uff8c\040\uff8c\041\uff8c\042\uff8c\046\uff8c\047\uff8c\052\uff8c" +
    "\054\uff8c\001\002\000\044\026\uff89\027\uff89\030\uff89\031" +
    "\uff89\032\uff89\033\uff89\034\uff89\035\uff89\036\uff89\037\uff89" +
    "\040\uff89\041\uff89\042\uff89\046\uff89\047\uff89\052\uff89\054" +
    "\uff89\001\002\000\022\012\164\021\127\022\167\023\174" +
    "\024\162\025\170\027\161\051\173\001\002\000\044\026" +
    "\uff82\027\uff82\030\uff82\031\uff82\032\uff82\033\uff82\034\uff82" +
    "\035\uff82\036\uff82\037\uff82\040\uff82\041\uff82\042\uff82\046" +
    "\uff82\047\uff82\052\uff82\054\uff82\001\002\000\010\026\177" +
    "\027\200\052\176\001\002\000\044\026\uff7f\027\uff7f\030" +
    "\uff7f\031\uff7f\032\uff7f\033\uff7f\034\uff7f\035\uff7f\036\uff7f" +
    "\037\uff7f\040\uff7f\041\uff7f\042\uff7f\046\uff7f\047\uff7f\052" +
    "\uff7f\054\uff7f\001\002\000\020\012\uff78\021\uff78\022\uff78" +
    "\023\uff78\024\uff78\025\uff78\051\uff78\001\002\000\020\012" +
    "\uff77\021\uff77\022\uff77\023\uff77\024\uff77\025\uff77\051\uff77" +
    "\001\002\000\020\012\164\021\127\022\167\023\174\024" +
    "\162\025\170\051\173\001\002\000\044\026\uff8a\027\uff8a" +
    "\030\204\031\205\032\203\033\uff8a\034\uff8a\035\uff8a\036" +
    "\uff8a\037\uff8a\040\uff8a\041\uff8a\042\uff8a\046\uff8a\047\uff8a" +
    "\052\uff8a\054\uff8a\001\002\000\020\012\uff74\021\uff74\022" +
    "\uff74\023\uff74\024\uff74\025\uff74\051\uff74\001\002\000\020" +
    "\012\uff76\021\uff76\022\uff76\023\uff76\024\uff76\025\uff76\051" +
    "\uff76\001\002\000\020\012\uff75\021\uff75\022\uff75\023\uff75" +
    "\024\uff75\025\uff75\051\uff75\001\002\000\020\012\164\021" +
    "\127\022\167\023\174\024\162\025\170\051\173\001\002" +
    "\000\044\026\uff88\027\uff88\030\uff88\031\uff88\032\uff88\033" +
    "\uff88\034\uff88\035\uff88\036\uff88\037\uff88\040\uff88\041\uff88" +
    "\042\uff88\046\uff88\047\uff88\052\uff88\054\uff88\001\002\000" +
    "\026\003\212\012\uffad\021\uffad\022\uffad\023\uffad\024\uffad" +
    "\025\uffad\027\uffad\051\uffad\052\211\001\002\000\044\026" +
    "\uffab\027\uffab\030\uffab\031\uffab\032\uffab\033\uffab\034\uffab" +
    "\035\uffab\036\uffab\037\uffab\040\uffab\041\uffab\042\uffab\046" +
    "\uffab\047\uffab\052\uffab\054\uffab\001\002\000\004\052\221" +
    "\001\002\000\022\012\164\021\127\022\167\023\174\024" +
    "\162\025\170\027\161\051\173\001\002\000\012\026\177" +
    "\027\200\047\uffa9\052\uffa9\001\002\000\006\047\216\052" +
    "\217\001\002\000\022\012\164\021\127\022\167\023\174" +
    "\024\162\025\170\027\161\051\173\001\002\000\044\026" +
    "\uffac\027\uffac\030\uffac\031\uffac\032\uffac\033\uffac\034\uffac" +
    "\035\uffac\036\uffac\037\uffac\040\uffac\041\uffac\042\uffac\046" +
    "\uffac\047\uffac\052\uffac\054\uffac\001\002\000\012\026\177" +
    "\027\200\047\uffa8\052\uffa8\001\002\000\044\026\uffaa\027" +
    "\uffaa\030\uffaa\031\uffaa\032\uffaa\033\uffaa\034\uffaa\035\uffaa" +
    "\036\uffaa\037\uffaa\040\uffaa\041\uffaa\042\uffaa\046\uffaa\047" +
    "\uffaa\052\uffaa\054\uffaa\001\002\000\046\026\uff85\027\uff85" +
    "\030\uff85\031\uff85\032\uff85\033\uff85\034\uff85\035\uff85\036" +
    "\uff85\037\uff85\040\uff85\041\uff85\042\uff85\046\uff85\047\uff85" +
    "\052\uff85\053\223\054\uff85\001\002\000\022\012\164\021" +
    "\127\022\167\023\174\024\162\025\170\027\161\051\173" +
    "\001\002\000\010\026\177\027\200\054\225\001\002\000" +
    "\044\026\uff86\027\uff86\030\uff86\031\uff86\032\uff86\033\uff86" +
    "\034\uff86\035\uff86\036\uff86\037\uff86\040\uff86\041\uff86\042" +
    "\uff86\046\uff86\047\uff86\052\uff86\054\uff86\001\002\000\004" +
    "\022\232\001\002\000\004\052\230\001\002\000\004\046" +
    "\231\001\002\000\026\005\uff94\007\uff94\011\uff94\013\uff94" +
    "\014\uff94\015\uff94\017\uff94\021\uff94\055\uff94\056\uff94\001" +
    "\002\000\004\052\uff93\001\002\000\044\026\uff8b\027\uff8b" +
    "\030\204\031\205\032\203\033\uff8b\034\uff8b\035\uff8b\036" +
    "\uff8b\037\uff8b\040\uff8b\041\uff8b\042\uff8b\046\uff8b\047\uff8b" +
    "\052\uff8b\054\uff8b\001\002\000\026\005\uffa0\007\uffa0\011" +
    "\uffa0\013\uffa0\014\uffa0\015\uffa0\017\uffa0\021\uffa0\055\uffa0" +
    "\056\uffa0\001\002\000\024\003\241\012\164\021\127\022" +
    "\167\023\174\024\162\025\170\027\161\051\173\001\002" +
    "\000\006\042\264\052\uff9f\001\002\000\010\041\uff9b\042" +
    "\uff9b\052\uff9b\001\002\000\030\026\177\027\200\033\255" +
    "\034\254\035\261\036\260\037\257\040\262\041\uff99\042" +
    "\uff99\052\uff99\001\002\000\004\052\uff9e\001\002\000\010" +
    "\041\252\042\uff9c\052\uff9c\001\002\000\004\052\244\001" +
    "\002\000\022\005\146\011\140\013\150\014\124\015\136" +
    "\017\133\021\127\055\141\001\002\000\024\005\uffa6\011" +
    "\uffa6\013\uffa6\014\uffa6\015\uffa6\017\uffa6\021\uffa6\055\uffa6" +
    "\056\uffa6\001\002\000\026\005\uffc2\007\247\011\uffc2\013" +
    "\uffc2\014\uffc2\015\uffc2\017\uffc2\021\uffc2\055\uffc2\056\uffc2" +
    "\001\002\000\022\005\146\011\140\013\150\014\124\015" +
    "\136\017\133\021\127\055\141\001\002\000\024\005\uffa5" +
    "\011\uffa5\013\uffa5\014\uffa5\015\uffa5\017\uffa5\021\uffa5\055" +
    "\uffa5\056\uffa5\001\002\000\026\005\uffa7\007\uffa7\011\uffa7" +
    "\013\uffa7\014\uffa7\015\uffa7\017\uffa7\021\uffa7\055\uffa7\056" +
    "\uffa7\001\002\000\022\012\164\021\127\022\167\023\174" +
    "\024\162\025\170\027\161\051\173\001\002\000\010\041" +
    "\uff9a\042\uff9a\052\uff9a\001\002\000\022\012\uff7d\021\uff7d" +
    "\022\uff7d\023\uff7d\024\uff7d\025\uff7d\027\uff7d\051\uff7d\001" +
    "\002\000\022\012\uff7e\021\uff7e\022\uff7e\023\uff7e\024\uff7e" +
    "\025\uff7e\027\uff7e\051\uff7e\001\002\000\022\012\164\021" +
    "\127\022\167\023\174\024\162\025\170\027\161\051\173" +
    "\001\002\000\022\012\uff7a\021\uff7a\022\uff7a\023\uff7a\024" +
    "\uff7a\025\uff7a\027\uff7a\051\uff7a\001\002\000\022\012\uff7b" +
    "\021\uff7b\022\uff7b\023\uff7b\024\uff7b\025\uff7b\027\uff7b\051" +
    "\uff7b\001\002\000\022\012\uff7c\021\uff7c\022\uff7c\023\uff7c" +
    "\024\uff7c\025\uff7c\027\uff7c\051\uff7c\001\002\000\022\012" +
    "\uff79\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\027\uff79" +
    "\051\uff79\001\002\000\014\026\177\027\200\041\uff98\042" +
    "\uff98\052\uff98\001\002\000\022\012\164\021\127\022\167" +
    "\023\174\024\162\025\170\027\161\051\173\001\002\000" +
    "\010\041\252\042\uff9d\052\uff9d\001\002\000\004\021\274" +
    "\001\002\000\024\003\271\012\164\021\127\022\167\023" +
    "\174\024\162\025\170\027\161\051\173\001\002\000\010" +
    "\026\177\027\200\054\273\001\002\000\004\054\272\001" +
    "\002\000\060\026\uff8d\027\uff8d\030\uff8d\031\uff8d\032\uff8d" +
    "\033\uff8d\034\uff8d\035\uff8d\036\uff8d\037\uff8d\040\uff8d\041" +
    "\uff8d\042\uff8d\043\uff8d\044\uff8d\045\uff8d\046\uff8d\047\uff8d" +
    "\050\uff8d\051\uff8d\052\uff8d\053\uff8d\054\uff8d\001\002\000" +
    "\060\026\uff8f\027\uff8f\030\uff8f\031\uff8f\032\uff8f\033\uff8f" +
    "\034\uff8f\035\uff8f\036\uff8f\037\uff8f\040\uff8f\041\uff8f\042" +
    "\uff8f\043\uff8f\044\uff8f\045\uff8f\046\uff8f\047\uff8f\050\uff8f" +
    "\051\uff8f\052\uff8f\053\uff8f\054\uff8f\001\002\000\060\026" +
    "\uff90\027\uff90\030\uff90\031\uff90\032\uff90\033\uff90\034\uff90" +
    "\035\uff90\036\uff90\037\uff90\040\uff90\041\uff90\042\uff90\043" +
    "\uff90\044\uff90\045\uff90\046\uff90\047\uff90\050\uff90\051\uff90" +
    "\052\uff90\053\uff90\054\uff90\001\002\000\024\003\241\012" +
    "\164\021\127\022\167\023\174\024\162\025\170\027\161" +
    "\051\173\001\002\000\004\052\277\001\002\000\022\005" +
    "\146\011\140\013\150\014\124\015\136\017\133\021\127" +
    "\055\141\001\002\000\024\005\uffa2\011\uffa2\013\uffa2\014" +
    "\uffa2\015\uffa2\017\uffa2\021\uffa2\055\uffa2\056\uffa2\001\002" +
    "\000\026\005\uffa3\007\uffa3\011\uffa3\013\uffa3\014\uffa3\015" +
    "\uffa3\017\uffa3\021\uffa3\055\uffa3\056\uffa3\001\002\000\024" +
    "\005\146\011\140\013\150\014\124\015\136\017\133\021" +
    "\127\055\141\056\303\001\002\000\026\005\uffb7\007\uffb7" +
    "\011\uffb7\013\uffb7\014\uffb7\015\uffb7\017\uffb7\021\uffb7\055" +
    "\uffb7\056\uffb7\001\002\000\026\005\uffae\007\uffae\011\uffae" +
    "\013\uffae\014\uffae\015\uffae\017\uffae\021\uffae\055\uffae\056" +
    "\uffae\001\002\000\010\026\177\027\200\046\307\001\002" +
    "\000\026\005\uff97\007\uff97\011\uff97\013\uff97\014\uff97\015" +
    "\uff97\017\uff97\021\uff97\055\uff97\056\uff97\001\002\000\026" +
    "\005\uff96\007\uff96\011\uff96\013\uff96\014\uff96\015\uff96\017" +
    "\uff96\021\uff96\055\uff96\056\uff96\001\002\000\004\021\127" +
    "\001\002\000\004\052\312\001\002\000\004\046\313\001" +
    "\002\000\026\005\uff95\007\uff95\011\uff95\013\uff95\014\uff95" +
    "\015\uff95\017\uff95\021\uff95\055\uff95\056\uff95\001\002\000" +
    "\004\046\324\001\002\000\024\003\321\012\164\021\127" +
    "\022\167\023\174\024\162\025\170\027\161\051\173\001" +
    "\002\000\004\046\uffb0\001\002\000\004\046\uffaf\001\002" +
    "\000\010\026\177\027\200\046\323\001\002\000\004\046" +
    "\322\001\002\000\026\005\uffb2\007\uffb2\011\uffb2\013\uffb2" +
    "\014\uffb2\015\uffb2\017\uffb2\021\uffb2\055\uffb2\056\uffb2\001" +
    "\002\000\026\005\uffb3\007\uffb3\011\uffb3\013\uffb3\014\uffb3" +
    "\015\uffb3\017\uffb3\021\uffb3\055\uffb3\056\uffb3\001\002\000" +
    "\026\005\uffb1\007\uffb1\011\uffb1\013\uffb1\014\uffb1\015\uffb1" +
    "\017\uffb1\021\uffb1\055\uffb1\056\uffb1\001\002\000\004\021" +
    "\013\001\002\000\006\047\uffc8\052\uffc8\001\002\000\006" +
    "\047\uffc5\052\uffc5\001\002\000\010\047\uffd9\052\uffd9\053" +
    "\070\001\002\000\006\047\uffc6\052\uffc6\001\002\000\012" +
    "\006\uffd5\010\uffd5\021\uffd5\055\uffd5\001\002\000\004\055" +
    "\uffd4\001\002\000\004\055\uffd3\001\002\000\006\046\346" +
    "\047\345\001\002\000\006\046\uffe3\047\uffe3\001\002\000" +
    "\010\046\uffd9\047\uffd9\053\070\001\002\000\006\046\342" +
    "\047\341\001\002\000\004\021\337\001\002\000\012\006" +
    "\uffe7\010\uffe7\021\uffe7\055\uffe7\001\002\000\006\046\uffe5" +
    "\047\uffe5\001\002\000\006\046\uffe2\047\uffe2\001\002\000" +
    "\004\021\337\001\002\000\012\006\uffe6\010\uffe6\021\uffe6" +
    "\055\uffe6\001\002\000\006\046\uffe4\047\uffe4\001\002\000" +
    "\010\016\103\021\013\056\351\001\002\000\004\002\001" +
    "\001\002\000\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\350\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\053\005\001\001\000\004\003\007\001\001\000\002" +
    "\001\001\000\016\004\016\005\017\010\013\011\014\014" +
    "\015\057\010\001\001\000\002\001\001\000\004\017\347" +
    "\001\001\000\002\001\001\000\006\012\337\013\335\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\010\023\057" +
    "\010\001\001\000\002\001\001\000\006\006\026\007\025" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\056\034\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\007\041" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\007" +
    "\044\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\100\047\001\001\000\004\015\051\001" +
    "\001\000\004\057\332\001\001\000\002\001\001\000\004" +
    "\101\053\001\001\000\004\047\054\001\001\000\010\050" +
    "\056\057\057\102\055\001\001\000\004\016\074\001\001" +
    "\000\002\001\001\000\004\077\060\001\001\000\006\051" +
    "\063\052\065\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\072\066\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\052\073\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\017\076\001\001\000\010" +
    "\020\101\057\077\060\103\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\103\105\001\001\000\002\001\001\000" +
    "\012\021\111\022\112\023\113\057\107\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\023\115\057\107\001\001" +
    "\000\002\001\001\000\004\047\117\001\001\000\006\050" +
    "\056\057\057\001\001\000\004\024\121\001\001\000\052" +
    "\025\150\026\155\027\146\030\124\031\134\032\144\033" +
    "\154\034\153\035\156\036\141\037\127\040\131\041\151" +
    "\042\133\054\122\055\143\064\136\073\125\074\152\076" +
    "\142\001\001\000\004\075\313\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\016\054" +
    "\165\055\143\061\171\062\304\063\170\064\164\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\024\301\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\016\054\165\055\143\061\171" +
    "\062\162\063\170\064\164\001\001\000\014\054\165\055" +
    "\143\061\171\063\232\064\164\001\001\000\002\001\001" +
    "\000\006\043\226\045\200\001\001\000\004\057\221\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\046\205\001\001\000\002\001" +
    "\001\000\016\054\165\055\143\061\171\062\174\063\170" +
    "\064\164\001\001\000\002\001\001\000\004\045\200\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\054\165\055\143\061\171\063\201\064\164\001" +
    "\001\000\004\046\205\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\054\165\055\143\061" +
    "\206\064\164\001\001\000\002\001\001\000\004\104\212" +
    "\001\001\000\002\001\001\000\002\001\001\000\020\054" +
    "\165\055\143\061\171\062\213\063\170\064\164\065\214" +
    "\001\001\000\004\045\200\001\001\000\002\001\001\000" +
    "\016\054\165\055\143\061\171\062\217\063\170\064\164" +
    "\001\001\000\002\001\001\000\004\045\200\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\054\165\055\143" +
    "\061\171\062\223\063\170\064\164\001\001\000\004\045" +
    "\200\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\046\205\001\001\000\002\001\001\000\026" +
    "\054\165\055\143\061\171\062\237\063\170\064\164\066" +
    "\235\067\242\070\241\071\236\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\044\255\045\200\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\052" +
    "\025\244\026\245\027\146\030\124\031\134\032\144\033" +
    "\154\034\153\035\156\036\141\037\127\040\131\041\151" +
    "\042\133\054\122\055\143\064\136\073\125\074\152\076" +
    "\142\001\001\000\002\001\001\000\002\001\001\000\050" +
    "\026\250\027\247\030\124\031\134\032\144\033\154\034" +
    "\153\035\156\036\141\037\127\040\131\041\151\042\133" +
    "\054\122\055\143\064\136\073\125\074\152\076\142\001" +
    "\001\000\002\001\001\000\002\001\001\000\020\054\165" +
    "\055\143\061\171\062\237\063\170\064\164\071\252\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\054\165\055\143\061\171\062\262\063\170\064" +
    "\164\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\045\200\001\001\000" +
    "\022\054\165\055\143\061\171\062\237\063\170\064\164" +
    "\070\264\071\236\001\001\000\002\001\001\000\002\001" +
    "\001\000\016\054\165\055\143\061\171\062\267\063\170" +
    "\064\164\001\001\000\004\045\200\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\026\054\165\055\143\061\171\062\237\063\170\064" +
    "\164\066\235\067\275\070\241\071\236\001\001\000\002" +
    "\001\001\000\050\026\300\027\277\030\124\031\134\032" +
    "\144\033\154\034\153\035\156\036\141\037\127\040\131" +
    "\041\151\042\133\054\122\055\143\064\136\073\125\074" +
    "\152\076\142\001\001\000\002\001\001\000\002\001\001" +
    "\000\052\025\150\026\155\027\146\030\124\031\134\032" +
    "\144\033\154\034\153\035\156\036\141\037\127\040\131" +
    "\041\151\042\133\054\122\055\143\064\136\073\125\074" +
    "\152\076\142\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\045\200\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\054\310\055\143\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\054\165\055\143\061\171\062\317\063\170\064\164" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\045" +
    "\200\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\023\325\057\107\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\072\330" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\072\343\001\001\000\002\001\001\000\004\013" +
    "\342\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\013\346\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\020\101\057\077\060\103\001\001" +
    "\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	Tab.init(); // Universe scope
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "string", stringType));
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "bool", boolType));

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null) 
		//log.info(s.toString() + " " + s.value.toString());
	return s;

    }



	public static final Struct stringType = new Struct(Struct.Array, new Struct(Struct.Char, Tab.noType));
	public static final Struct boolType = new Struct(Struct.Int);
	public static final String boolTrue = "true", boolFalse = "false", classThis = "this";

	Logger log = Logger.getLogger(getClass());
	Map<Struct, ArrayList<Struct>> inheritanceTable = new LinkedHashMap<Struct, ArrayList<Struct>>();
	Struct type;
	public boolean semError = false;
	
	boolean inClass = false,
			inMain = false,
			method = false,
			attrDef = false;
	
	// nivo A
	int globalVarCnt = 0,			//	definicije glob prom
		localVarCnt = 0,			//	definicije lokalnih prom u mainu
		globalConstCnt = 0,			//	definicije glob konstanti
		globalArrayCnt = 0;			// 	deklaracije glob nizova
		
	// nivo B
	int functionCnt = 0,			// definicije funkcija u glavnom programu
		blockCnt = 0,				//	blokovi naredbi
		callCnt = 0,				//	pozivi funkcija u main metodi
		formParCnt = 0;				//	deklaracije form argumenata funkcija
		
	// nivo C
	int nestedClassCnt = 0,			//	definicije unutr klasa
		nestedClassMethodCnt = 0,	//	definicije metoda unutr klasa
		nestedClassAttrCnt = 0;		//	deklaracije polja unutr klasa 
   
    
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal syntax error - ", cur_token);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void report_error(String message, Object info) {
    	semError = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol) {
            msg.append (" at row ").append(((Symbol)info).left);
            msg.append (" - unrecognized symbol '").append(((Symbol)info).value + "'");
        }
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at row ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
    public void report_debug(String message) {
    	StringBuilder msg = new StringBuilder(message); 
        log.debug(msg.toString());
    }
    
    public String objToString(Obj o) {
    	SymbolTableVisitor stv = new DumpSymbolTableVisitor();
    	
    	stv.visitObjNode(o);
    	return stv.getOutput();
    }
    
     public boolean assignableTo(Obj dst, Struct src) {
    	Struct dstType = dst.getType();
    	
    	if (src.assignableTo(dstType))
    		return true;
    	/*
		if (dstType.getKind() == Struct.Array && dstType.getElemType().equals(Tab.charType) && src.equals(stringType))
			return true;
		*/
		if (dstType.getKind() == Struct.Class && src.getKind() == Struct.Class)
			if (inheritanceTable.containsKey(src))
				if (inheritanceTable.get(src).contains(dstType))
					return true;
	
		return false;
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	int constValue = 0;
	ArrayList<String> constStrings = new ArrayList<String> ();
	Obj currentMethod = null;
	Obj currentClass = null;
	Struct superClass = null;
	Obj currentDesignator = null;
	Obj currentCall = null;
	Stack<Obj> funcCalls = new Stack<Obj> ();
	Iterator<Obj> iterator = null;
	Stack<Iterator<Obj>> iterators = new Stack<Iterator<Obj>> ();
	int pos = 0;
	Stack<Integer> positions = new Stack<Integer> ();
	boolean returnFound = false;
	int fpPos = 0, actPars = 0;
	boolean isVoid = false;
	boolean inWhile = false;

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Mulop ::= MOD 
            {
              String RESULT =null;
		 RESULT = "%"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Mulop ::= DIV 
            {
              String RESULT =null;
		 RESULT = "/"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Mulop ::= MUL 
            {
              String RESULT =null;
		 RESULT = "*"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Addop ::= MINUS 
            {
              String RESULT =null;
		 RESULT = "-"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Addop ::= PLUS 
            {
              String RESULT =null;
		 RESULT = "+"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Relop ::= LEQ 
            {
              String RESULT =null;
		 RESULT = "<="; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // Relop ::= LESS 
            {
              String RESULT =null;
		 RESULT = "<"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Relop ::= GREQ 
            {
              String RESULT =null;
		 RESULT = ">="; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // Relop ::= GRE 
            {
              String RESULT =null;
		 RESULT = ">"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Relop ::= NEQ 
            {
              String RESULT =null;
		 RESULT = "!="; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Relop ::= EQ 
            {
              String RESULT =null;
		 RESULT = "=="; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Factor ::= LPAREN Expr RPAREN 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = expr; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Factor ::= BOOL 
            {
              Struct RESULT =null;
		 RESULT = parser.boolType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Factor ::= STRING 
            {
              Struct RESULT =null;
		 RESULT = parser.stringType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Factor ::= CHAR 
            {
              Struct RESULT =null;
		 RESULT = Tab.charType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Factor ::= NUMBER 
            {
              Struct RESULT =null;
		 RESULT = Tab.intType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // Factor ::= Designator 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = desig.getType(); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Factor ::= NEW Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
			RESULT = Tab.noType;
		 	if (type.getKind() != Struct.Class)
		 		parser.report_error("Semantics error " + typeleft + " - variable must be of a class type", null);
		 	else
		 		RESULT = type;
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // Factor ::= NEW Type LBRACKET Expr RBRACKET 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			RESULT = Tab.noType;
			// menjano
		 	if (expr.equals(Tab.intType))
		 		RESULT = new Struct(Struct.Array, type);
		 	else
		 		parser.report_error("Semantics error at row " + exprleft + " - number of elements must be an integer value", null);		 	
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // Factor ::= Function 
            {
              Struct RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct func = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = func; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Term ::= Term Mulop Factor 
            {
              Struct RESULT =null;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int factorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int factorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct factor = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (!term.equals(Tab.intType) || !factor.equals(Tab.intType))
				parser.report_error("Semantics error at row " + factorleft + " - expression must be an integer value", null);
			else
				RESULT = term;
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // Term ::= Factor 
            {
              Struct RESULT =null;
		int factorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int factorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct factor = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = factor; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // Expr ::= Expr Addop Term 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int addopleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int addopright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String addop = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		RESULT = Tab.noType;
		if (expr.equals(Tab.intType) && term.equals(Tab.intType))
			RESULT = expr;
		else if (addop.equals("+")) {
			if (expr.equals(parser.stringType) && term.equals(parser.stringType))
				RESULT = parser.stringType;
			else
				parser.report_error("Semantics error at row " + exprleft + " - expressions must be integers or strings", null);
		} else
			parser.report_error("Semantics error at row " + exprleft + " - expressions must be integers", null);		
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // Expr ::= MINUS Term 
            {
              Struct RESULT =null;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		RESULT = Tab.noType;
		if (!term.equals(Tab.intType))
				parser.report_error("Semantics error at row " + termleft + " - expression must be an integer value", null);
		else
			RESULT = term;
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // Expr ::= Term 
            {
              Struct RESULT =null;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = term; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // DesignatorList ::= DesignatorList LBRACKET error RBRACKET 
            {
              Obj RESULT =null;
		int arrayleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int arrayright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj array = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 
					parser.report_debug("Successful error recovery - array indexing");
					
					if (array.getType().getKind() != Struct.Array) { 
                    	parser.report_error("Semantics error at row " + arrayleft + " - expected an array",null);
                    	RESULT = Tab.noObj;
                    } else {
                    	RESULT = new Obj (Obj.Elem, array.getName(), array.getType().getElemType());
                    } 
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // DesignatorList ::= IDENT 
            {
              Obj RESULT =null;
		int identleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int identright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String ident = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
					if (ident.equals(parser.classThis) && parser.inClass) {							 			
						RESULT = currentClass;
					} else {
						Obj o = Tab.find(ident);
						if (o != Tab.noObj) {
							// parser.report_info("Use of " + parser.objToString(o) + " at row " + identleft,null);		
						} else {
	                    	parser.report_error("Semantics error at row " + identleft + " - symbol '" + ident + "' not found",null);					
						}
						RESULT = o;
					}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // DesignatorList ::= DesignatorList LBRACKET Expr RBRACKET 
            {
              Obj RESULT =null;
		int arrayleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int arrayright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj array = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					if (array.getType().getKind() != Struct.Array) { 
                    	parser.report_error("Semantics error at row " + arrayleft + " - expected an array",null);
                    	RESULT = Tab.noObj;
                    } else {
                    	// menjano obrati paznju na RESULT
                    	RESULT = Tab.noObj;
					 	if (!expr.equals(Tab.intType))
					 		parser.report_error("Semantics error at row " + exprleft + " - array index must be an integer value", null);		 	
                    	else
                    		RESULT = new Obj (Obj.Elem, array.getName(), array.getType().getElemType());
                    }
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // DesignatorList ::= DesignatorList STOP IDENT 
            {
              Obj RESULT =null;
		int clleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int clright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj cl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int fieldleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int fieldright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String field = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					if (cl.getType().getKind() != Struct.Class) { 
                    	parser.report_error("Semantics error at row " + clleft + " - expected a class",null);
                    	RESULT = Tab.noObj;
                    } else {
                    	Obj o = cl.getType().getMembers().searchKey(field);
	                    if (o == null) {
	                    	o = Tab.noObj;
	                    	parser.report_error("Semantics error at row " + clleft + " - class attribute '" + field + "' doesn't exist",null);
	                    } else {
	                    	// parser.report_info("Use of " + parser.objToString(o) + " at row " + clleft,null);
	                     }
	                    RESULT = o;
                    }     
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // Designator ::= DesignatorList 
            {
              Obj RESULT =null;
		int dlistleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dlistright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj dlist = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = dlist; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // NumberOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumberOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // NumberOpt ::= COMMA NUMBER 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumberOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // PrintStatement ::= PRINT LPAREN Expr NumberOpt RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
				if (expr != Tab.intType && expr != Tab.charType && expr != parser.boolType && expr != parser.stringType)
								parser.report_error("Semantics error at row " + exprleft + " - parameter must be an integer/character/boolean or a string value", null);							
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("PrintStatement",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // ReadStatement ::= READ LPAREN Designator RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
					if (desig != null)
						if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
							parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be a variable", null);
						} else {
							if (desig.getType() != Tab.intType && desig.getType() != Tab.charType && desig.getType() != parser.boolType && desig.getType() != parser.stringType)
								parser.report_error("Semantics error at row " + desigleft + " - parameter must be an integer/character/boolean or a string value", null);							
						}
					else
						parser.report_error("Desig je null", null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReadStatement",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // ReturnStatement ::= RETURN Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			    	returnFound = true;
			    	Struct currMethType = currentMethod.getType();
			    	if (isVoid)
			    		parser.report_error("Semantics error at row " + exprleft + " - function does not need a return value", null);
			    	else if (!expr.compatibleWith(currMethType))
			    		parser.report_error("Semantics error at row " + exprleft + " - return types are not compatible", null);
			    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnStatement",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // ReturnStatement ::= RETURN SEMI_COMMA 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					returnFound = true;
				 	Struct currMethType = currentMethod.getType();
				 	if (!isVoid) {
				 		parser.report_error("Semantics error at row " + dummyleft + " - function missing a return value", null);
				 	}	  	 
			    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnStatement",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // CondFact ::= Expr Relop Expr 
            {
              Struct RESULT =null;
		int typeLleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeLright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct typeL = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String op = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int typeRleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeRright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct typeR = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (typeL.getKind() == Struct.Array || typeR.getKind() == Struct.Array || typeL.getKind() == Struct.Class || typeR.getKind() == Struct.Class) {
				if (!op.equals("!=") && !op.equals("=="))
					parser.report_error("Semantics error at row " + typeLleft + " - operator '" + op + "' not allowed for class/array types", null);
				else {
					if (!typeL.compatibleWith(typeR))
						parser.report_error("Semantics error at row " + typeLleft + " - incompatible types", null);
					else
						RESULT = parser.boolType;
				}
			}
			else {
				if (!typeL.compatibleWith(typeR))
					parser.report_error("Semantics error at row " + typeLleft + " - incompatible types", null);
				else
					RESULT = parser.boolType;
			}		
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // CondFact ::= Expr 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = expr; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // CondTerm ::= CondTerm AND CondFact 
            {
              Struct RESULT =null;
		int typeLleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeLright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct typeL = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeRleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeRright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct typeR = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (typeL.equals(parser.boolType) && typeR.equals(parser.boolType))
				RESULT = parser.boolType;
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // CondTerm ::= CondFact 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // ConditionCheck ::= CondTerm 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  	RESULT = Tab.noType;
				if (type.equals(parser.boolType))
					RESULT = parser.boolType;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionCheck",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // ConditionCheck ::= ConditionCheck OR CondTerm 
            {
              Struct RESULT =null;
		int typeLleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeLright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct typeL = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeRleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeRright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct typeR = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  	RESULT = Tab.noType;
				if (typeL.equals(parser.boolType) && typeR.equals(parser.boolType))
					RESULT = parser.boolType;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionCheck",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // Condition ::= error 
            {
              Struct RESULT =null;
		 parser.report_debug("Successful error recovery - condition of an if/while construction"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // Condition ::= ConditionCheck 
            {
              Struct RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct result = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				if (!result.equals(parser.boolType))
					parser.report_error("Semantics error at row " + resultleft + " - expression must be a boolean value", null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // BreakStatement ::= BREAK SEMI_COMMA 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					if (!inWhile)
						parser.report_error("Semantics error at row " + dummyleft + " - 'break' statement can only be used inside a while loop", null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BreakStatement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // WhileTerm ::= WHILE 
            {
              Object RESULT =null;
		 inWhile = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("WhileTerm",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // UnmatchedWhileStatement ::= WhileTerm LPAREN Condition RPAREN Unmatched 
            {
              Object RESULT =null;
		 inWhile = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("UnmatchedWhileStatement",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // MatchedWhileStatement ::= WhileTerm LPAREN Condition RPAREN Matched 
            {
              Object RESULT =null;
		 inWhile = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MatchedWhileStatement",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // IfTerm ::= IF 
            {
              Object RESULT =null;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IfTerm",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // UnmatchedIfStatement ::= IfTerm LPAREN Condition RPAREN Matched ELSE Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("UnmatchedIfStatement",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // UnmatchedIfStatement ::= IfTerm LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("UnmatchedIfStatement",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // MatchedIfStatement ::= IfTerm LPAREN Condition RPAREN Matched ELSE Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MatchedIfStatement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // ActPars ::= ActPars COMMA Expr 
            {
              Struct RESULT =null;
		int actParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int actParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct actPars = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (currentCall != null)
				if (currentCall.getLevel() > pos) {
					if (!iterator.next().getType().compatibleWith(expr))
						parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + (pos+1) + ". parameter", null);
					else
						RESULT = expr;
					pos++;
				} else 
					parser.report_error("Semantics error at row " + exprleft + " - number of parameters doesn't match", null);	
			else
				parser.report_error("Current call je null", null);	
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // ActPars ::= Expr 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			RESULT = Tab.noType;
			if (currentCall != null)
				if (currentCall.getLevel() > pos) {
					if (currentCall.getName().equals("len")) {
						if (expr.getKind() != Struct.Array)
							parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + (pos+1) + ". parameter", null);
						else
							RESULT = expr;
					} else {
						if (!iterator.next().getType().compatibleWith(expr))
							parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + (pos+1) + ". parameter", null);
						else
							RESULT = expr;
					}
					pos++;
				} else 
					parser.report_error("Semantics error at row " + exprleft + " - number of parameters doesn't match", null);	
			else 
				parser.report_error("Current call je null", null);	
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // Function ::= Designator LPAREN error RPAREN 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 parser.report_debug("Successful error recovery - actual parameters list"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Function",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // Function ::= Designator LPAREN RPAREN 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
			 if (parser.inMain) 
					parser.callCnt++;

				RESULT = Tab.noType;
				if (desig != null) {
			 		if (desig.getKind() != Obj.Meth)
			 			parser.report_error("Semantics error at row " + desigleft + " - variable must be a global function or a class method", null);
			 		else {
							if (desig.getLevel() > 0)
								parser.report_error("Semantics error at row " + desigleft + " - function '" + desig.getName() + "' missing parameters", null);
							RESULT = desig.getType();
						}
			 	} else
			 		parser.report_error("Desig je null", null);
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Function",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // Function ::= Designator LPAREN NT$5 ActPars RPAREN 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String dummy = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (currentCall != null) {
				RESULT = currentCall.getType();
				if (currentCall.getLevel() > pos)
			 			parser.report_error("Semantics error at row " + dummyleft + " - function '" + currentCall.getName() + "' missing parameters", null);										
				if (funcCalls.size() > 0) {
					currentCall = funcCalls.pop();
					iterator = iterators.pop();
					pos = positions.pop();
				} else {
					currentCall = null;
					iterator = null;
					pos = 0;
				}
		 	} else
		 		parser.report_error("Current call je null", null);
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Function",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // NT$5 ::= 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

		 	if (parser.inMain) 
				parser.callCnt++;
				
		 	if (desig != null) {
		 		if (desig.getKind() != Obj.Meth)
		 			parser.report_error("Semantics error at row " + desigleft + " - variable must be a global function or a class method", null);
		 		else {
		 			if (currentCall != null) {
							funcCalls.push(currentCall);
							iterators.push(iterator);
							positions.push(pos);
						}
					currentCall = desig;
					iterator = currentCall.getLocalSymbols().iterator();
					pos = 0;
					if (currentCall.getLevel() <= 0)
			 			parser.report_error("Semantics error at row " + desigleft + " - function doesn't need parameters", null);					
				}
		 	} else
		 		parser.report_error("Desig je null", null);
		 	
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // FunctionCall ::= Function SEMI_COMMA 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FunctionCall",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // IncDec ::= DEC 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IncDec",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // IncDec ::= INC 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IncDec",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // SideEffect ::= Designator IncDec SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if (desig != null) {
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
					} else {
						if (!desig.getType().equals(Tab.intType))
							parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
					}
				} else
					parser.report_error("Desig je null", null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("SideEffect",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // Assignment ::= Designator EQUALS error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - value assignment"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // Assignment ::= Designator EQUALS Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
					
				if (desig != null) {
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be a variable", null);
						desig = Tab.noObj;
					}
					// menjano
	 				//if (!expr.assignableTo(desig.getType()))
	 				if (!parser.assignableTo(desig, expr))
	 					parser.report_error("Semantics error at row " + desigleft + " - incompatible types", null);		 	
				} else
					parser.report_error("Desig je null", null);
						
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // ExprStatement ::= FunctionCall 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // ExprStatement ::= SideEffect 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // ExprStatement ::= Assignment 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Matched ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
		 parser.blockCnt++; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Matched ::= PrintStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Matched ::= ReadStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Matched ::= ReturnStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Matched ::= BreakStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Matched ::= MatchedWhileStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Matched ::= MatchedIfStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Matched ::= ExprStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Unmatched ::= UnmatchedWhileStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Unmatched ::= UnmatchedIfStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // Statement ::= Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // Statement ::= Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FormPar ::= Type error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - formal parameter declaration"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // FormPar ::= Type IDENT BracketsOpt 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int parNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int parNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String parName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 					
				parser.formParCnt++;
				
				Obj o = Tab.currentScope().findSymbol(parName);
	 			if (o == null) {
	 				if (!brack.booleanValue())
	 					o = Tab.insert(Obj.Var, parName, type);
	 				else
	 					o = Tab.insert(Obj.Var, parName, new Struct(Struct.Array, type));
	 				o.setFpPos(fpPos);
	 				fpPos++;
	 				// parser.report_info("Formal parameter '" + parName + "' declaration at row " + parNameleft, null);
	 			} else {
	 				parser.report_error("Semantics error at row " + parNameleft + " - multiple definition of '" + parName + "'", null);
	 			} 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // FormPars ::= FormPar 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FormPars ::= error COMMA FormPar 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - formal parameter declaration"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // FormPars ::= FormPars COMMA FormPar 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // FormParsOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsOpt",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // FormParsOpt ::= FormPars 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsOpt",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // ReturnType ::= VOID 
            {
              Struct RESULT =null;
		 isVoid = true; RESULT = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // ReturnType ::= Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 isVoid = (type == Tab.noType); RESULT = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // MethodDecl ::= ReturnType IDENT NT$4 LPAREN FormParsOpt RPAREN LocalVarDeclList LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String dummy = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			   	  if (parser.inMain && fpPos > 0)
					parser.report_error("Semantics error at row " + methNameleft + " - 'main' function cannot have parameters", null);
					
			   	  // da li brojimo i main u funkcije
			   	  parser.method = false;
			   	  parser.blockCnt++;
			   	  if (!parser.inClass) 
			   	  	parser.functionCnt++;
			   	  else 
			   	  	parser.nestedClassMethodCnt++;
			   	  if (parser.inMain) 
			   	  	parser.inMain = false;
			   	  	
			   	  if (!returnFound && !isVoid)
			   	 	parser.report_error("Semantics error at row " + dummyleft + " - function '" + methName + "' missing 'return' statement", null);
			   	  
			   	  currentMethod.setLevel(fpPos);
			   	  Tab.chainLocalSymbols(currentMethod);
			   	  Tab.closeScope();
			   	  
			   	  returnFound = isVoid = false;
				  currentMethod = null;
				  fpPos = 0;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // NT$4 ::= 
            {
              Object RESULT =null;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
			   	  parser.method = true; 
			   	  if (!parser.inClass && methName.equals("main")) 
			   	  	parser.inMain = true;
			   	  
			   	  Obj o = Tab.currentScope().findSymbol(methName);
				  if (o == null) {
		 				currentMethod = Tab.insert(Obj.Meth, methName, retType);
		 				// parser.report_info("Function '" + methName + "' definition at row " + methNameleft, null);
		 		  } else {
		 		  		currentMethod = o;
		 		  		if (!((superClass != null) && (superClass.getMembers().searchKey(methName) != null)))
		 					parser.report_error("Semantics error at row " + methNameleft + " - multiple definition of a function '" + methName + "'", null);
		 		  		else {
		 		  			// parser.report_info("Class method '" + methName + "' redefinition at row " + methNameleft, null);
		 		  		}
		 		  }	 
			   	  Tab.openScope();
			   	  
			   	  if (parser.inMain && !isVoid)
			   	  	parser.report_error("Semantics error at row " + methNameleft + " - function '" + methName + "' must be VOID", null);  	   
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // Methods ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Methods",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // Methods ::= LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Methods",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // Extends ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // Extends ::= EXTENDS error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - class inheritance"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // Extends ::= EXTENDS Type 
            {
              Object RESULT =null;
		int outerClassleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int outerClassright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct outerClass = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				if (!(outerClass.getKind() == Struct.Class))
					parser.report_error("Semantics error at row " + outerClassleft + " - outer class must be of a class type", null);
				else if (outerClass == currentClass.getType())
					parser.report_error("Semantics error at row " + outerClassleft + " - class cannot inherit itself", null);
				else {
					// parser.report_info("Class inheritance at row " + outerClassleft, null);
					superClass = outerClass;
					Iterator<Obj> exIter = superClass.getMembers().symbols().iterator();
					Obj o = null;
					for (int i = 0; i < superClass.getNumberOfFields(); i++) {
						o = exIter.next();
						if (o.getKind() == Obj.Fld) {
							if (o.getType().getKind() != Struct.Array)
				 				Tab.insert(o.getKind(), o.getName(), o.getType());
			 				else
			 					Tab.insert(o.getKind(), o.getName(), new Struct(Struct.Array, o.getType().getElemType()));
						}
					}
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // ClassDecl ::= CLASS IDENT NT$1 Extends LBRACE NT$2 LocalVarDeclList NT$3 Methods RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		 
			  	parser.inClass = false; 
			  	parser.nestedClassCnt++;
			  	Tab.chainLocalSymbols(currentClass.getType());
			   	Tab.closeScope();
			   	currentClass = null;
			   	superClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // NT$3 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
 
			  	parser.attrDef = false; 
			  	currentClass.getType().setMembers(Tab.currentScope().getLocals());
			  	if (superClass != null) {
			  		Iterator<Obj> exIter = superClass.getMembers().symbols().iterator();
					Obj meth = null;
					Obj o = null;
					while (exIter.hasNext()) {
						meth = exIter.next();
						if (meth.getKind() == Obj.Meth) {
			 				o = Tab.insert(Obj.Meth, meth.getName(), meth.getType());
			 				Tab.openScope();
			 				Iterator<Obj> methIter = meth.getLocalSymbols().iterator();
			 				int i = 0;
			 				while (methIter.hasNext()) {
			 					Obj par = methIter.next();
			 					if (par.getType().getKind() != Struct.Array)
				 					par = Tab.insert(Obj.Var, par.getName(), par.getType());
				 				else
				 					par = Tab.insert(Obj.Var, par.getName(), new Struct(Struct.Array, par.getType().getElemType()));
				 				if (i < meth.getLevel())
				 					par.setFpPos(i++);		
			 				}
			 				Tab.chainLocalSymbols(o);
			 				Tab.closeScope();
			 				o.setLevel(i);
						}
					}
			  	}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
 
			  	parser.attrDef = true;
			  	if (superClass != null) {
			  		ArrayList<Struct> list = new ArrayList<Struct> ();
					list.add(superClass);
					if (parser.inheritanceTable.containsKey(superClass)) {
						list.addAll(parser.inheritanceTable.get(superClass));
					}
					parser.inheritanceTable.put(currentClass.getType(), list);
				}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$1 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
			  	parser.inClass = true;
			  	
			  	Obj o = Tab.find(className);
			  	if (o == Tab.noObj) {
	 				currentClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
	 				// parser.report_info("Class '" + className + "' definition at row " + classNameleft, null);
	 			} else {
	 				currentClass = o;
	 				parser.report_error("Semantics error at row " + classNameleft + " - multiple definition of a class '" + className + "'", null);
	 			}
	 			Tab.openScope();		  		
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // BracketsOpt ::= 
            {
              Boolean RESULT =null;
		 
			 	RESULT = new Boolean(false);
			   	if (!parser.method && !parser.inClass) 
			   		parser.globalVarCnt++; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BracketsOpt",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // BracketsOpt ::= LBRACKET RBRACKET 
            {
              Boolean RESULT =null;
		 
			 	RESULT = new Boolean(true);
			 	if (!parser.method && !parser.inClass) 
			 		parser.globalArrayCnt++; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BracketsOpt",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // LocalVariable ::= IDENT BracketsOpt 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 	
				// brojimo samo lokalne u main funkciji
				if (parser.inMain)
					parser.localVarCnt++;
				else if (parser.inClass && parser.attrDef) 
					parser.nestedClassAttrCnt++;
	 			
	 				if (parser.attrDef) {
	 					Obj o = Tab.currentScope().findSymbol(varName);
	 					if (o == null) {
		 					if (!brack.booleanValue())
			 					Tab.insert(Obj.Fld, varName, parser.type);
		 					else
		 						Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, parser.type));
		 					// parser.report_info("Class attribute '" + varName + "' declaration at row " + varNameleft, null);
	 					} else {
	 						if ((superClass != null) && (superClass.getMembers().searchKey(varName) != null)) {
	 							int adr = o.getAdr();
	 							Tab.currentScope().getLocals().deleteKey(varName);
	 							if (!brack.booleanValue())
				 					o = Tab.insert(Obj.Fld, varName, parser.type);
			 					else
			 						o = Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, parser.type));
	 							o.setAdr(adr);
	 							// parser.report_info("Class attribute '" + varName + "' redefinition at row " + varNameleft, null);
	 						} else
	 							parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of a class attribute '" + varName + "'", null);				
	 					}
	 				} else {
	 					Obj o = Tab.currentScope().findSymbol(varName);
 						if (o == null) {
		 					if (!brack.booleanValue())
			 					Tab.insert(Obj.Var, varName, parser.type);
		 					else
		 						Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
		 					// parser.report_info("Local variable '" + varName + "' declaration at row " + varNameleft, null);
		 				} else {
		 					parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of a local variable '" + varName + "'", null);
		 				}
	 				}	
	 			
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVariable",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // LocalVarList ::= LocalVariable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // LocalVarList ::= LocalVarList COMMA LocalVariable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // LocalVarDecl ::= Type error 
            {
              Object RESULT =null;
		 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration");
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // LocalVarDecl ::= Type error SEMI_COMMA 
            {
              Object RESULT =null;
		 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration"); 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // LocalVarDecl ::= Type NT$0 LocalVarList SEMI_COMMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // NT$0 ::= 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 parser.type = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // Variable ::= IDENT BracketsOpt 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 	
	 			Obj o = Tab.find(varName);
	 			if (o == Tab.noObj) {
	 				if (!brack.booleanValue())
		 				Tab.insert(Obj.Var, varName, parser.type);
	 				else
	 					Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
	 				// parser.report_info("Global variable '" + varName + "' declaration at row " + varNameleft, null);	
	 			} else {
	 				parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of '" + varName + "'", null);
	 			}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Variable",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // VarList ::= Variable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VarList ::= error COMMA Variable 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - global variable definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VarList ::= VarList COMMA Variable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VarDecl ::= VarType error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - global variable definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // VarDecl ::= VarType VarList SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // Constant ::= IDENT EQUALS error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - value assignment (constant)"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Constant",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // Constant ::= IDENT EQUALS ConstType 
            {
              Object RESULT =null;
		int constNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int constNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String constName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int constTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int constTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct constType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				parser.globalConstCnt++;
				Obj o = Tab.find(constName);
	 			if (o == Tab.noObj) {
	 				o = Tab.insert(Obj.Con, constName, parser.type);
	 				// parser.report_info("Constant '" + constName + "' declaration at row " + constNameleft, null);
	 				o.setAdr(constValue);
	 				constValue = 0;
	 			} else {
	 				parser.report_error("Semantics error at row " + constNameleft + " - multiple definition of '" + constName + "'", null);
	 			}
	 			
	 			if (!o.getType().compatibleWith(constType))
	 				parser.report_error("Semantics error at row " + constNameleft + " - incompatible types", null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Constant",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ConstList ::= Constant 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // ConstList ::= error COMMA Constant 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // ConstList ::= ConstList COMMA Constant 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // ConstDecl ::= CONST error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // ConstDecl ::= CONST VarType error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ConstDecl ::= CONST VarType ConstList SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
		Obj typeNode = Tab.find(typeName);
		if (typeNode == Tab.noObj) {
			parser.report_error("Semantics error at row " + typeNameleft + " - type '" + typeName + "' not found in symbol table", null);
			RESULT = Tab.noType;
		}
		else {
			if (Obj.Type == typeNode.getKind()) {
				RESULT = typeNode.getType();
			}
			else {
				parser.report_error("Semantics error at row " + typeNameleft + " - name '" + typeName + "' doesn't represent a type", null);
				RESULT = Tab.noType;
			}
		}
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // VarType ::= Type 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.type = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarType",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // ConstType ::= STRING 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				RESULT = parser.stringType; 
				constStrings.add(val);
				constValue = constStrings.size() - 1; 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ConstType ::= BOOL 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean val = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				RESULT = parser.boolType; 
				if (val.booleanValue())
					constValue = 1; 
				else
					constValue = 0;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ConstType ::= CHAR 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character val = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = Tab.charType; constValue = val; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ConstType ::= NUMBER 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer val = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = Tab.intType; constValue = val; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // MethodDeclList ::= MethodDeclList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // LocalVarDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // LocalVarDeclList ::= LocalVarDeclList LocalVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // List ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // List ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // List ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Lists ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Lists",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // Lists ::= Lists List 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Lists",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgramName ::= IDENT 
            {
              Obj RESULT =null;
		int progNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int progNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String progName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
				Tab.openScope();
				// parser.report_info("PARSING the program '" + progName + "' at row " + progNameleft, null);
				
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgramName",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROGRAM ProgramName Lists LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String dummy = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			Tab.chainLocalSymbols(p);
			Obj o = Tab.find("main");
			if (o == Tab.noObj || o.getKind() != Obj.Meth)
				parser.report_error("Semantics error at row " + dummyleft + " - program missing 'main' function", null);
			Tab.closeScope();
			
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

