
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Feb 08 09:16:02 CET 2016
//----------------------------------------------------

package compiler;

import java_cup.runtime.*;
import java.util.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.DumpSymbolTableVisitor;
import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;
import rs.etf.pp1.mj.runtime.Code;
import compiler.StringHelper;
import compiler.ClassHelper;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Feb 08 09:16:02 CET 2016
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\223\000\002\100\002\000\002\002\011\000\002\002" +
    "\004\000\002\054\003\000\002\003\004\000\002\003\002" +
    "\000\002\004\003\000\002\004\003\000\002\004\003\000" +
    "\002\014\004\000\002\014\002\000\002\023\004\000\002" +
    "\023\002\000\002\057\003\000\002\057\003\000\002\057" +
    "\003\000\002\057\003\000\002\010\003\000\002\060\003" +
    "\000\002\005\006\000\002\005\006\000\002\005\005\000" +
    "\002\006\005\000\002\006\005\000\002\006\003\000\002" +
    "\007\005\000\002\007\005\000\002\011\005\000\002\011" +
    "\005\000\002\012\005\000\002\012\005\000\002\012\003" +
    "\000\002\013\004\000\002\101\002\000\002\015\006\000" +
    "\002\015\005\000\002\015\004\000\002\016\005\000\002" +
    "\016\003\000\002\017\004\000\002\073\004\000\002\073" +
    "\002\000\002\102\002\000\002\103\002\000\002\104\002" +
    "\000\002\020\014\000\002\021\004\000\002\021\004\000" +
    "\002\021\002\000\002\022\005\000\002\022\002\000\002" +
    "\105\002\000\002\106\002\000\002\024\015\000\002\061" +
    "\003\000\002\061\003\000\002\025\003\000\002\025\002" +
    "\000\002\026\005\000\002\026\005\000\002\026\003\000" +
    "\002\027\005\000\002\027\004\000\002\030\004\000\002" +
    "\030\002\000\002\031\003\000\002\031\003\000\002\033" +
    "\003\000\002\033\003\000\002\032\003\000\002\032\003" +
    "\000\002\032\003\000\002\032\003\000\002\032\003\000" +
    "\002\032\003\000\002\032\003\000\002\032\005\000\002" +
    "\043\003\000\002\043\003\000\002\043\003\000\002\074" +
    "\006\000\002\074\006\000\002\075\005\000\002\052\003" +
    "\000\002\052\003\000\002\076\004\000\002\107\002\000" +
    "\002\065\007\000\002\065\005\000\002\065\006\000\002" +
    "\066\003\000\002\066\005\000\002\034\004\000\002\035" +
    "\007\000\002\035\004\000\002\077\010\000\002\036\003" +
    "\000\002\037\007\000\002\040\007\000\002\042\003\000" +
    "\002\041\004\000\002\070\003\000\002\070\003\000\002" +
    "\067\005\000\002\067\003\000\002\071\003\000\002\071" +
    "\005\000\002\072\003\000\002\072\005\000\002\044\004" +
    "\000\002\044\005\000\002\045\007\000\002\046\010\000" +
    "\002\053\004\000\002\053\002\000\002\055\003\000\002" +
    "\056\005\000\002\110\002\000\002\056\007\000\002\056" +
    "\003\000\002\056\006\000\002\063\003\000\002\063\004" +
    "\000\002\111\002\000\002\063\006\000\002\064\003\000" +
    "\002\064\005\000\002\062\003\000\002\062\007\000\002" +
    "\062\004\000\002\062\003\000\002\062\003\000\002\062" +
    "\003\000\002\062\003\000\002\062\003\000\002\062\005" +
    "\000\002\047\003\000\002\047\003\000\002\047\003\000" +
    "\002\047\003\000\002\047\003\000\002\047\003\000\002" +
    "\050\003\000\002\050\003\000\002\051\003\000\002\051" +
    "\003\000\002\051\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\355\000\004\004\005\001\002\000\004\002\357\001" +
    "\002\000\004\021\007\001\002\000\012\006\ufffc\010\ufffc" +
    "\021\ufffc\055\ufffc\001\002\000\012\006\ufffe\010\ufffe\021" +
    "\ufffe\055\ufffe\001\002\000\012\006\021\010\022\021\013" +
    "\055\012\001\002\000\006\003\ufff0\021\ufff0\001\002\000" +
    "\010\016\001\021\001\056\001\001\002\000\054\003\uffef" +
    "\021\uffef\026\uffef\027\uffef\030\uffef\031\uffef\032\uffef\033" +
    "\uffef\034\uffef\035\uffef\036\uffef\037\uffef\040\uffef\041\uffef" +
    "\042\uffef\046\uffef\047\uffef\052\uffef\053\uffef\054\uffef\055" +
    "\uffef\001\002\000\006\003\341\021\343\001\002\000\012" +
    "\006\ufffa\010\ufffa\021\ufffa\055\ufffa\001\002\000\012\006" +
    "\ufff9\010\ufff9\021\ufff9\055\ufff9\001\002\000\012\006\ufffb" +
    "\010\ufffb\021\ufffb\055\ufffb\001\002\000\012\006\ufffd\010" +
    "\ufffd\021\ufffd\055\ufffd\001\002\000\004\021\047\001\002" +
    "\000\006\003\023\021\013\001\002\000\004\046\046\001" +
    "\002\000\006\003\025\021\030\001\002\000\006\046\044" +
    "\047\043\001\002\000\006\046\uffe9\047\uffe9\001\002\000" +
    "\006\046\041\047\040\001\002\000\004\043\031\001\002" +
    "\000\014\003\033\022\035\023\037\024\036\025\032\001" +
    "\002\000\006\046\ufff1\047\ufff1\001\002\000\006\046\uffe7" +
    "\047\uffe7\001\002\000\006\046\uffe8\047\uffe8\001\002\000" +
    "\006\046\ufff4\047\ufff4\001\002\000\006\046\ufff2\047\ufff2" +
    "\001\002\000\006\046\ufff3\047\ufff3\001\002\000\004\021" +
    "\030\001\002\000\012\006\uffee\010\uffee\021\uffee\055\uffee" +
    "\001\002\000\006\046\uffeb\047\uffeb\001\002\000\004\021" +
    "\030\001\002\000\012\006\uffed\010\uffed\021\uffed\055\uffed" +
    "\001\002\000\006\046\uffea\047\uffea\001\002\000\012\006" +
    "\uffec\010\uffec\021\uffec\055\uffec\001\002\000\006\020\uffd7" +
    "\055\uffd7\001\002\000\006\020\051\055\uffd1\001\002\000" +
    "\006\003\340\021\013\001\002\000\004\055\053\001\002" +
    "\000\010\021\uffd6\055\uffd6\056\uffd6\001\002\000\010\021" +
    "\ufff7\055\ufff7\056\ufff7\001\002\000\010\021\013\055\uffd5" +
    "\056\uffd5\001\002\000\010\021\ufff8\055\ufff8\056\ufff8\001" +
    "\002\000\006\003\326\021\uffe0\001\002\000\006\055\062" +
    "\056\uffcf\001\002\000\004\056\324\001\002\000\010\016" +
    "\ufff5\021\ufff5\056\ufff5\001\002\000\010\016\067\021\013" +
    "\056\065\001\002\000\004\021\uffcb\001\002\000\004\056" +
    "\uffd0\001\002\000\010\016\ufff6\021\ufff6\056\ufff6\001\002" +
    "\000\004\021\uffca\001\002\000\004\021\071\001\002\000" +
    "\004\051\uffce\001\002\000\004\051\073\001\002\000\010" +
    "\003\075\021\013\052\uffc8\001\002\000\006\003\317\021" +
    "\320\001\002\000\004\047\315\001\002\000\004\052\103" +
    "\001\002\000\006\047\101\052\uffc9\001\002\000\006\047" +
    "\uffc5\052\uffc5\001\002\000\004\021\013\001\002\000\006" +
    "\047\uffc7\052\uffc7\001\002\000\006\021\ufff7\055\ufff7\001" +
    "\002\000\006\021\013\055\105\001\002\000\024\005\uffcd" +
    "\011\uffcd\013\uffcd\014\uffcd\015\uffcd\017\uffcd\021\uffcd\055" +
    "\uffcd\056\uffcd\001\002\000\024\005\uffc1\011\uffc1\013\uffc1" +
    "\014\uffc1\015\uffc1\017\uffc1\021\uffc1\055\uffc1\056\uffc1\001" +
    "\002\000\024\005\134\011\126\013\136\014\112\015\124" +
    "\017\120\021\114\055\127\056\116\001\002\000\022\005" +
    "\134\011\126\013\136\014\112\015\124\017\120\021\114" +
    "\055\127\001\002\000\012\043\303\044\304\045\305\051" +
    "\177\001\002\000\004\051\276\001\002\000\026\005\uffbb" +
    "\007\uffbb\011\uffbb\013\uffbb\014\uffbb\015\uffbb\017\uffbb\021" +
    "\uffbb\055\uffbb\056\uffbb\001\002\000\060\026\uff8a\027\uff8a" +
    "\030\uff8a\031\uff8a\032\uff8a\033\uff8a\034\uff8a\035\uff8a\036" +
    "\uff8a\037\uff8a\040\uff8a\041\uff8a\042\uff8a\043\uff8a\044\uff8a" +
    "\045\uff8a\046\uff8a\047\uff8a\050\uff8a\051\uff8a\052\uff8a\053" +
    "\uff8a\054\uff8a\001\002\000\026\005\uffb4\007\uffb4\011\uffb4" +
    "\013\uffb4\014\uffb4\015\uffb4\017\uffb4\021\uffb4\055\uffb4\056" +
    "\uffb4\001\002\000\010\016\uffcc\021\uffcc\056\uffcc\001\002" +
    "\000\026\005\uffbc\007\uffbc\011\uffbc\013\uffbc\014\uffbc\015" +
    "\uffbc\017\uffbc\021\uffbc\055\uffbc\056\uffbc\001\002\000\004" +
    "\051\uff9e\001\002\000\026\005\uffb8\007\uffb8\011\uffb8\013" +
    "\uffb8\014\uffb8\015\uffb8\017\uffb8\021\uffb8\055\uffb8\056\uffb8" +
    "\001\002\000\026\005\uffb6\007\uffb6\011\uffb6\013\uffb6\014" +
    "\uffb6\015\uffb6\017\uffb6\021\uffb6\055\uffb6\056\uffb6\001\002" +
    "\000\024\005\uffbe\011\uffbe\013\uffbe\014\uffbe\015\uffbe\017" +
    "\uffbe\021\uffbe\055\uffbe\056\uffbe\001\002\000\024\012\152" +
    "\021\114\022\155\023\162\024\150\025\156\027\147\046" +
    "\274\051\161\001\002\000\004\046\272\001\002\000\004" +
    "\051\uffa1\001\002\000\024\005\uffc1\011\uffc1\013\uffc1\014" +
    "\uffc1\015\uffc1\017\uffc1\021\uffc1\055\uffc1\056\uffc1\001\002" +
    "\000\004\051\263\001\002\000\026\005\uffb2\007\uffb2\011" +
    "\uffb2\013\uffb2\014\uffb2\015\uffb2\017\uffb2\021\uffb2\055\uffb2" +
    "\056\uffb2\001\002\000\060\026\uff8e\027\uff8e\030\uff8e\031" +
    "\uff8e\032\uff8e\033\uff8e\034\uff8e\035\uff8e\036\uff8e\037\uff8e" +
    "\040\uff8e\041\uff8e\042\uff8e\043\uff8e\044\uff8e\045\uff8e\046" +
    "\uff8e\047\uff8e\050\253\051\uff8e\052\uff8e\053\254\054\uff8e" +
    "\001\002\000\004\051\224\001\002\000\004\046\223\001" +
    "\002\000\024\005\uffbf\011\uffbf\013\uffbf\014\uffbf\015\uffbf" +
    "\017\uffbf\021\uffbf\055\uffbf\056\uffbf\001\002\000\004\051" +
    "\146\001\002\000\024\005\uffc2\011\uffc2\013\uffc2\014\uffc2" +
    "\015\uffc2\017\uffc2\021\uffc2\055\uffc2\056\uffc2\001\002\000" +
    "\026\005\uffb7\007\uffb7\011\uffb7\013\uffb7\014\uffb7\015\uffb7" +
    "\017\uffb7\021\uffb7\055\uffb7\056\uffb7\001\002\000\026\005" +
    "\uffba\007\uffba\011\uffba\013\uffba\014\uffba\015\uffba\017\uffba" +
    "\021\uffba\055\uffba\056\uffba\001\002\000\026\005\uffb3\007" +
    "\uffb3\011\uffb3\013\uffb3\014\uffb3\015\uffb3\017\uffb3\021\uffb3" +
    "\055\uffb3\056\uffb3\001\002\000\024\005\uffbd\011\uffbd\013" +
    "\uffbd\014\uffbd\015\uffbd\017\uffbd\021\uffbd\055\uffbd\056\uffbd" +
    "\001\002\000\024\005\uffc0\011\uffc0\013\uffc0\014\uffc0\015" +
    "\uffc0\017\uffc0\021\uffc0\055\uffc0\056\uffc0\001\002\000\026" +
    "\005\uffb9\007\uffb9\011\uffb9\013\uffb9\014\uffb9\015\uffb9\017" +
    "\uffb9\021\uffb9\055\uffb9\056\uffb9\001\002\000\022\012\152" +
    "\021\114\022\155\023\162\024\150\025\156\027\147\051" +
    "\161\001\002\000\020\012\152\021\114\022\155\023\162" +
    "\024\150\025\156\051\161\001\002\000\044\026\uff7c\027" +
    "\uff7c\030\uff7c\031\uff7c\032\uff7c\033\uff7c\034\uff7c\035\uff7c" +
    "\036\uff7c\037\uff7c\040\uff7c\041\uff7c\042\uff7c\046\uff7c\047" +
    "\uff7c\052\uff7c\054\uff7c\001\002\000\012\026\165\027\166" +
    "\047\215\052\uff8f\001\002\000\004\021\013\001\002\000" +
    "\044\026\uff82\027\uff82\030\uff82\031\uff82\032\uff82\033\uff82" +
    "\034\uff82\035\uff82\036\uff82\037\uff82\040\uff82\041\uff82\042" +
    "\uff82\046\uff82\047\uff82\052\uff82\054\uff82\001\002\000\046" +
    "\026\uff7f\027\uff7f\030\uff7f\031\uff7f\032\uff7f\033\uff7f\034" +
    "\uff7f\035\uff7f\036\uff7f\037\uff7f\040\uff7f\041\uff7f\042\uff7f" +
    "\046\uff7f\047\uff7f\051\177\052\uff7f\054\uff7f\001\002\000" +
    "\044\026\uff7e\027\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e" +
    "\034\uff7e\035\uff7e\036\uff7e\037\uff7e\040\uff7e\041\uff7e\042" +
    "\uff7e\046\uff7e\047\uff7e\052\uff7e\054\uff7e\001\002\000\044" +
    "\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b\033\uff7b\034" +
    "\uff7b\035\uff7b\036\uff7b\037\uff7b\040\uff7b\041\uff7b\042\uff7b" +
    "\046\uff7b\047\uff7b\052\uff7b\054\uff7b\001\002\000\044\026" +
    "\uff88\027\uff88\030\173\031\174\032\172\033\uff88\034\uff88" +
    "\035\uff88\036\uff88\037\uff88\040\uff88\041\uff88\042\uff88\046" +
    "\uff88\047\uff88\052\uff88\054\uff88\001\002\000\044\026\uff84" +
    "\027\uff84\030\uff84\031\uff84\032\uff84\033\uff84\034\uff84\035" +
    "\uff84\036\uff84\037\uff84\040\uff84\041\uff84\042\uff84\046\uff84" +
    "\047\uff84\052\uff84\054\uff84\001\002\000\022\012\152\021" +
    "\114\022\155\023\162\024\150\025\156\027\147\051\161" +
    "\001\002\000\044\026\uff7d\027\uff7d\030\uff7d\031\uff7d\032" +
    "\uff7d\033\uff7d\034\uff7d\035\uff7d\036\uff7d\037\uff7d\040\uff7d" +
    "\041\uff7d\042\uff7d\046\uff7d\047\uff7d\052\uff7d\054\uff7d\001" +
    "\002\000\010\026\165\027\166\052\164\001\002\000\044" +
    "\026\uff7a\027\uff7a\030\uff7a\031\uff7a\032\uff7a\033\uff7a\034" +
    "\uff7a\035\uff7a\036\uff7a\037\uff7a\040\uff7a\041\uff7a\042\uff7a" +
    "\046\uff7a\047\uff7a\052\uff7a\054\uff7a\001\002\000\020\012" +
    "\uff73\021\uff73\022\uff73\023\uff73\024\uff73\025\uff73\051\uff73" +
    "\001\002\000\020\012\uff72\021\uff72\022\uff72\023\uff72\024" +
    "\uff72\025\uff72\051\uff72\001\002\000\020\012\uff86\021\uff86" +
    "\022\uff86\023\uff86\024\uff86\025\uff86\051\uff86\001\002\000" +
    "\020\012\152\021\114\022\155\023\162\024\150\025\156" +
    "\051\161\001\002\000\044\026\uff85\027\uff85\030\173\031" +
    "\174\032\172\033\uff85\034\uff85\035\uff85\036\uff85\037\uff85" +
    "\040\uff85\041\uff85\042\uff85\046\uff85\047\uff85\052\uff85\054" +
    "\uff85\001\002\000\020\012\uff6f\021\uff6f\022\uff6f\023\uff6f" +
    "\024\uff6f\025\uff6f\051\uff6f\001\002\000\020\012\uff71\021" +
    "\uff71\022\uff71\023\uff71\024\uff71\025\uff71\051\uff71\001\002" +
    "\000\020\012\uff70\021\uff70\022\uff70\023\uff70\024\uff70\025" +
    "\uff70\051\uff70\001\002\000\020\012\152\021\114\022\155" +
    "\023\162\024\150\025\156\051\161\001\002\000\044\026" +
    "\uff83\027\uff83\030\uff83\031\uff83\032\uff83\033\uff83\034\uff83" +
    "\035\uff83\036\uff83\037\uff83\040\uff83\041\uff83\042\uff83\046" +
    "\uff83\047\uff83\052\uff83\054\uff83\001\002\000\026\003\201" +
    "\012\uffab\021\uffab\022\uffab\023\uffab\024\uffab\025\uffab\027" +
    "\uffab\051\uffab\052\200\001\002\000\044\026\uffa9\027\uffa9" +
    "\030\uffa9\031\uffa9\032\uffa9\033\uffa9\034\uffa9\035\uffa9\036" +
    "\uffa9\037\uffa9\040\uffa9\041\uffa9\042\uffa9\046\uffa9\047\uffa9" +
    "\052\uffa9\054\uffa9\001\002\000\004\052\210\001\002\000" +
    "\022\012\152\021\114\022\155\023\162\024\150\025\156" +
    "\027\147\051\161\001\002\000\012\026\165\027\166\047" +
    "\uffa7\052\uffa7\001\002\000\006\047\205\052\206\001\002" +
    "\000\022\012\152\021\114\022\155\023\162\024\150\025" +
    "\156\027\147\051\161\001\002\000\044\026\uffaa\027\uffaa" +
    "\030\uffaa\031\uffaa\032\uffaa\033\uffaa\034\uffaa\035\uffaa\036" +
    "\uffaa\037\uffaa\040\uffaa\041\uffaa\042\uffaa\046\uffaa\047\uffaa" +
    "\052\uffaa\054\uffaa\001\002\000\012\026\165\027\166\047" +
    "\uffa6\052\uffa6\001\002\000\044\026\uffa8\027\uffa8\030\uffa8" +
    "\031\uffa8\032\uffa8\033\uffa8\034\uffa8\035\uffa8\036\uffa8\037" +
    "\uffa8\040\uffa8\041\uffa8\042\uffa8\046\uffa8\047\uffa8\052\uffa8" +
    "\054\uffa8\001\002\000\046\026\uff80\027\uff80\030\uff80\031" +
    "\uff80\032\uff80\033\uff80\034\uff80\035\uff80\036\uff80\037\uff80" +
    "\040\uff80\041\uff80\042\uff80\046\uff80\047\uff80\052\uff80\053" +
    "\212\054\uff80\001\002\000\022\012\152\021\114\022\155" +
    "\023\162\024\150\025\156\027\147\051\161\001\002\000" +
    "\010\026\165\027\166\054\214\001\002\000\044\026\uff81" +
    "\027\uff81\030\uff81\031\uff81\032\uff81\033\uff81\034\uff81\035" +
    "\uff81\036\uff81\037\uff81\040\uff81\041\uff81\042\uff81\046\uff81" +
    "\047\uff81\052\uff81\054\uff81\001\002\000\004\022\221\001" +
    "\002\000\004\052\217\001\002\000\004\046\220\001\002" +
    "\000\026\005\uff91\007\uff91\011\uff91\013\uff91\014\uff91\015" +
    "\uff91\017\uff91\021\uff91\055\uff91\056\uff91\001\002\000\004" +
    "\052\uff90\001\002\000\044\026\uff87\027\uff87\030\173\031" +
    "\174\032\172\033\uff87\034\uff87\035\uff87\036\uff87\037\uff87" +
    "\040\uff87\041\uff87\042\uff87\046\uff87\047\uff87\052\uff87\054" +
    "\uff87\001\002\000\026\005\uff9d\007\uff9d\011\uff9d\013\uff9d" +
    "\014\uff9d\015\uff9d\017\uff9d\021\uff9d\055\uff9d\056\uff9d\001" +
    "\002\000\024\003\230\012\152\021\114\022\155\023\162" +
    "\024\150\025\156\027\147\051\161\001\002\000\006\042" +
    "\251\052\uff9c\001\002\000\010\041\uff98\042\uff98\052\uff98" +
    "\001\002\000\030\026\165\027\166\033\242\034\241\035" +
    "\246\036\245\037\244\040\247\041\uff96\042\uff96\052\uff96" +
    "\001\002\000\004\052\uff9b\001\002\000\010\041\237\042" +
    "\uff99\052\uff99\001\002\000\004\052\233\001\002\000\022" +
    "\005\134\011\126\013\136\014\112\015\124\017\120\021" +
    "\114\055\127\001\002\000\024\005\uffa4\011\uffa4\013\uffa4" +
    "\014\uffa4\015\uffa4\017\uffa4\021\uffa4\055\uffa4\056\uffa4\001" +
    "\002\000\026\005\uffc0\007\236\011\uffc0\013\uffc0\014\uffc0" +
    "\015\uffc0\017\uffc0\021\uffc0\055\uffc0\056\uffc0\001\002\000" +
    "\022\005\uffa2\011\uffa2\013\uffa2\014\uffa2\015\uffa2\017\uffa2" +
    "\021\uffa2\055\uffa2\001\002\000\022\012\152\021\114\022" +
    "\155\023\162\024\150\025\156\027\147\051\161\001\002" +
    "\000\010\041\uff97\042\uff97\052\uff97\001\002\000\022\012" +
    "\uff78\021\uff78\022\uff78\023\uff78\024\uff78\025\uff78\027\uff78" +
    "\051\uff78\001\002\000\022\012\uff79\021\uff79\022\uff79\023" +
    "\uff79\024\uff79\025\uff79\027\uff79\051\uff79\001\002\000\022" +
    "\012\152\021\114\022\155\023\162\024\150\025\156\027" +
    "\147\051\161\001\002\000\022\012\uff75\021\uff75\022\uff75" +
    "\023\uff75\024\uff75\025\uff75\027\uff75\051\uff75\001\002\000" +
    "\022\012\uff76\021\uff76\022\uff76\023\uff76\024\uff76\025\uff76" +
    "\027\uff76\051\uff76\001\002\000\022\012\uff77\021\uff77\022" +
    "\uff77\023\uff77\024\uff77\025\uff77\027\uff77\051\uff77\001\002" +
    "\000\022\012\uff74\021\uff74\022\uff74\023\uff74\024\uff74\025" +
    "\uff74\027\uff74\051\uff74\001\002\000\014\026\165\027\166" +
    "\041\uff95\042\uff95\052\uff95\001\002\000\022\012\152\021" +
    "\114\022\155\023\162\024\150\025\156\027\147\051\161" +
    "\001\002\000\010\041\237\042\uff9a\052\uff9a\001\002\000" +
    "\004\021\262\001\002\000\024\003\255\012\uff8c\021\uff8c" +
    "\022\uff8c\023\uff8c\024\uff8c\025\uff8c\027\uff8c\051\uff8c\001" +
    "\002\000\004\054\261\001\002\000\022\012\152\021\114" +
    "\022\155\023\162\024\150\025\156\027\147\051\161\001" +
    "\002\000\010\026\165\027\166\054\260\001\002\000\060" +
    "\026\uff8b\027\uff8b\030\uff8b\031\uff8b\032\uff8b\033\uff8b\034" +
    "\uff8b\035\uff8b\036\uff8b\037\uff8b\040\uff8b\041\uff8b\042\uff8b" +
    "\043\uff8b\044\uff8b\045\uff8b\046\uff8b\047\uff8b\050\uff8b\051" +
    "\uff8b\052\uff8b\053\uff8b\054\uff8b\001\002\000\060\026\uff89" +
    "\027\uff89\030\uff89\031\uff89\032\uff89\033\uff89\034\uff89\035" +
    "\uff89\036\uff89\037\uff89\040\uff89\041\uff89\042\uff89\043\uff89" +
    "\044\uff89\045\uff89\046\uff89\047\uff89\050\uff89\051\uff89\052" +
    "\uff89\053\uff89\054\uff89\001\002\000\060\026\uff8d\027\uff8d" +
    "\030\uff8d\031\uff8d\032\uff8d\033\uff8d\034\uff8d\035\uff8d\036" +
    "\uff8d\037\uff8d\040\uff8d\041\uff8d\042\uff8d\043\uff8d\044\uff8d" +
    "\045\uff8d\046\uff8d\047\uff8d\050\uff8d\051\uff8d\052\uff8d\053" +
    "\uff8d\054\uff8d\001\002\000\024\003\230\012\152\021\114" +
    "\022\155\023\162\024\150\025\156\027\147\051\161\001" +
    "\002\000\004\052\265\001\002\000\022\005\134\011\126" +
    "\013\136\014\112\015\124\017\120\021\114\055\127\001" +
    "\002\000\024\005\uff9f\011\uff9f\013\uff9f\014\uff9f\015\uff9f" +
    "\017\uff9f\021\uff9f\055\uff9f\056\uff9f\001\002\000\026\005" +
    "\uffa0\007\uffa0\011\uffa0\013\uffa0\014\uffa0\015\uffa0\017\uffa0" +
    "\021\uffa0\055\uffa0\056\uffa0\001\002\000\024\005\134\011" +
    "\126\013\136\014\112\015\124\017\120\021\114\055\127" +
    "\056\271\001\002\000\026\005\uffb5\007\uffb5\011\uffb5\013" +
    "\uffb5\014\uffb5\015\uffb5\017\uffb5\021\uffb5\055\uffb5\056\uffb5" +
    "\001\002\000\026\005\uffac\007\uffac\011\uffac\013\uffac\014" +
    "\uffac\015\uffac\017\uffac\021\uffac\055\uffac\056\uffac\001\002" +
    "\000\010\026\165\027\166\046\275\001\002\000\026\005" +
    "\uff94\007\uff94\011\uff94\013\uff94\014\uff94\015\uff94\017\uff94" +
    "\021\uff94\055\uff94\056\uff94\001\002\000\026\005\uff93\007" +
    "\uff93\011\uff93\013\uff93\014\uff93\015\uff93\017\uff93\021\uff93" +
    "\055\uff93\056\uff93\001\002\000\004\021\114\001\002\000" +
    "\004\052\300\001\002\000\004\046\301\001\002\000\026" +
    "\005\uff92\007\uff92\011\uff92\013\uff92\014\uff92\015\uff92\017" +
    "\uff92\021\uff92\055\uff92\056\uff92\001\002\000\004\046\312" +
    "\001\002\000\024\003\307\012\152\021\114\022\155\023" +
    "\162\024\150\025\156\027\147\051\161\001\002\000\004" +
    "\046\uffae\001\002\000\004\046\uffad\001\002\000\010\026" +
    "\165\027\166\046\311\001\002\000\004\046\310\001\002" +
    "\000\026\005\uffb0\007\uffb0\011\uffb0\013\uffb0\014\uffb0\015" +
    "\uffb0\017\uffb0\021\uffb0\055\uffb0\056\uffb0\001\002\000\026" +
    "\005\uffb1\007\uffb1\011\uffb1\013\uffb1\014\uffb1\015\uffb1\017" +
    "\uffb1\021\uffb1\055\uffb1\056\uffb1\001\002\000\026\005\uffaf" +
    "\007\uffaf\011\uffaf\013\uffaf\014\uffaf\015\uffaf\017\uffaf\021" +
    "\uffaf\055\uffaf\056\uffaf\001\002\000\024\005\uffa3\011\uffa3" +
    "\013\uffa3\014\uffa3\015\uffa3\017\uffa3\021\uffa3\055\uffa3\056" +
    "\uffa3\001\002\000\026\005\uffa5\007\uffa5\011\uffa5\013\uffa5" +
    "\014\uffa5\015\uffa5\017\uffa5\021\uffa5\055\uffa5\056\uffa5\001" +
    "\002\000\004\021\013\001\002\000\006\047\uffc6\052\uffc6" +
    "\001\002\000\006\047\uffc3\052\uffc3\001\002\000\010\047" +
    "\uffd8\052\uffd8\053\322\001\002\000\006\047\uffc4\052\uffc4" +
    "\001\002\000\004\054\323\001\002\000\010\046\uffd9\047" +
    "\uffd9\052\uffd9\001\002\000\012\006\uffd4\010\uffd4\021\uffd4" +
    "\055\uffd4\001\002\000\004\021\330\001\002\000\012\021" +
    "\uffdd\046\327\055\uffdd\056\uffdd\001\002\000\010\021\uffde" +
    "\055\uffde\056\uffde\001\002\000\010\046\uffd8\047\uffd8\053" +
    "\322\001\002\000\006\046\334\047\333\001\002\000\006" +
    "\046\uffdb\047\uffdb\001\002\000\004\021\330\001\002\000" +
    "\010\021\uffdf\055\uffdf\056\uffdf\001\002\000\006\046\uffdc" +
    "\047\uffdc\001\002\000\006\046\uffda\047\uffda\001\002\000" +
    "\004\055\uffd3\001\002\000\004\055\uffd2\001\002\000\006" +
    "\046\352\047\351\001\002\000\006\046\uffe2\047\uffe2\001" +
    "\002\000\010\046\uffd8\047\uffd8\053\322\001\002\000\006" +
    "\046\346\047\345\001\002\000\004\021\343\001\002\000" +
    "\012\006\uffe6\010\uffe6\021\uffe6\055\uffe6\001\002\000\006" +
    "\046\uffe4\047\uffe4\001\002\000\006\046\uffe1\047\uffe1\001" +
    "\002\000\004\021\343\001\002\000\012\006\uffe5\010\uffe5" +
    "\021\uffe5\055\uffe5\001\002\000\006\046\uffe3\047\uffe3\001" +
    "\002\000\010\016\ufff5\021\ufff5\056\ufff5\001\002\000\010" +
    "\016\067\021\013\056\356\001\002\000\004\002\000\001" +
    "\002\000\004\002\uffff\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\355\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\054\005\001\001\000\004\003\007\001\001\000\002" +
    "\001\001\000\016\004\017\005\016\010\013\011\014\020" +
    "\015\060\010\001\001\000\002\001\001\000\004\100\353" +
    "\001\001\000\002\001\001\000\006\012\343\013\341\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\010\023\060" +
    "\010\001\001\000\002\001\001\000\006\006\026\007\025" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\057\033\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\007\041" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\007" +
    "\044\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\102\047\001\001\000\004\021\051\001" +
    "\001\000\004\060\336\001\001\000\002\001\001\000\004" +
    "\103\053\001\001\000\004\014\054\001\001\000\010\015" +
    "\055\060\056\104\057\001\001\000\002\001\001\000\004" +
    "\101\324\001\001\000\004\022\060\001\001\000\002\001" +
    "\001\000\004\023\062\001\001\000\010\024\065\060\063" +
    "\061\067\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\105\071\001\001\000\002\001\001\000\012\025\075\026" +
    "\076\027\077\060\073\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\027\101\060\073\001\001\000\002\001\001" +
    "\000\004\014\103\001\001\000\006\015\055\060\056\001" +
    "\001\000\004\106\105\001\001\000\004\030\106\001\001" +
    "\000\054\031\136\032\143\033\134\034\112\035\122\036" +
    "\132\037\140\040\142\041\144\042\127\043\116\044\120" +
    "\045\137\046\121\055\110\056\131\065\124\074\114\075" +
    "\141\076\130\077\107\001\001\000\052\032\313\033\312" +
    "\034\112\035\122\036\132\037\140\040\142\041\144\042" +
    "\127\043\116\044\120\045\137\046\121\055\110\056\131" +
    "\065\124\074\114\075\141\076\130\077\107\001\001\000" +
    "\004\052\301\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\055\153\056\131\062" +
    "\157\063\272\064\156\065\152\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\030\267\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\016\055\153\056\131\062\157\063\150\064\156" +
    "\065\152\001\001\000\014\055\153\056\131\062\157\064" +
    "\221\065\152\001\001\000\002\001\001\000\006\050\166" +
    "\053\215\001\001\000\004\060\210\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\051\174\001\001\000\002\001\001\000\016\055" +
    "\153\056\131\062\157\063\162\064\156\065\152\001\001" +
    "\000\002\001\001\000\004\050\166\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\111\167" +
    "\001\001\000\014\055\153\056\131\062\157\064\170\065" +
    "\152\001\001\000\004\051\174\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\055\153\056" +
    "\131\062\175\065\152\001\001\000\002\001\001\000\004" +
    "\107\201\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\055\153\056\131\062\157\063\202\064\156\065\152" +
    "\066\203\001\001\000\004\050\166\001\001\000\002\001" +
    "\001\000\016\055\153\056\131\062\157\063\206\064\156" +
    "\065\152\001\001\000\002\001\001\000\004\050\166\001" +
    "\001\000\002\001\001\000\002\001\001\000\016\055\153" +
    "\056\131\062\157\063\212\064\156\065\152\001\001\000" +
    "\004\050\166\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\051\174\001\001\000\002\001\001" +
    "\000\026\055\153\056\131\062\157\063\226\064\156\065" +
    "\152\067\224\070\231\071\230\072\225\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\047\242\050\166\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\054\031\233\032\234\033\134\034\112\035\122\036" +
    "\132\037\140\040\142\041\144\042\127\043\116\044\120" +
    "\045\137\046\121\055\110\056\131\065\124\074\114\075" +
    "\141\076\130\077\107\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\020\055\153\056\131\062" +
    "\157\063\226\064\156\065\152\072\237\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\016\055" +
    "\153\056\131\062\157\063\247\064\156\065\152\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\050\166\001\001\000\022\055\153" +
    "\056\131\062\157\063\226\064\156\065\152\071\251\072" +
    "\225\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\110\255\001\001\000\002\001\001\000\016\055\153\056" +
    "\131\062\157\063\256\064\156\065\152\001\001\000\004" +
    "\050\166\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\055\153\056\131\062\157\063\226" +
    "\064\156\065\152\067\224\070\263\071\230\072\225\001" +
    "\001\000\002\001\001\000\052\032\266\033\265\034\112" +
    "\035\122\036\132\037\140\040\142\041\144\042\127\043" +
    "\116\044\120\045\137\046\121\055\110\056\131\065\124" +
    "\074\114\075\141\076\130\077\107\001\001\000\002\001" +
    "\001\000\002\001\001\000\054\031\136\032\143\033\134" +
    "\034\112\035\122\036\132\037\140\040\142\041\144\042" +
    "\127\043\116\044\120\045\137\046\121\055\110\056\131" +
    "\065\124\074\114\075\141\076\130\077\107\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\050\166\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\055\276\056" +
    "\131\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\055\153\056\131\062" +
    "\157\063\305\064\156\065\152\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\050\166\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\027\315\060" +
    "\073\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\073\320\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\016\330\017\331" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\073" +
    "\335\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\017\334\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\073\347\001\001\000" +
    "\002\001\001\000\004\013\346\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\013\352\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\023\354" +
    "\001\001\000\010\024\065\060\063\061\067\001\001\000" +
    "\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 2;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	Tab.init(); // Universe scope
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "bool", StringHelper.boolType));
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "string", StringHelper.stringType));

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null) 
		//log.info(s.toString() + " " + s.value.toString());
	return s;

    }


	
	// NIVO A
	public static final String boolTrue = "true", 
							   boolFalse = "false", 
							   classThis = "this";

	Logger log = Logger.getLogger(getClass());
	Map<Struct, ArrayList<Struct>> inheritanceTable = new LinkedHashMap<Struct, ArrayList<Struct>>();
	Struct type;
	public boolean semError = false;
	
	boolean inClass = false,
			inMain = false,
			method = false,
			attrDef = false;
	
	// nivo A
	int globalVarCnt = 0,			//	definicije glob prom
		localVarCnt = 0,			//	definicije lokalnih prom u mainu
		globalConstCnt = 0,			//	definicije glob konstanti
		globalArrayCnt = 0;			// 	deklaracije glob nizova
		
	// nivo B
	int functionCnt = 0,			// definicije funkcija u glavnom programu
		blockCnt = 0,				//	blokovi naredbi
		callCnt = 0,				//	pozivi funkcija u main metodi
		formParCnt = 0;				//	deklaracije form argumenata funkcija
		
	// nivo C
	int nestedClassCnt = 0,			//	definicije unutr klasa
		nestedClassMethodCnt = 0,	//	definicije metoda unutr klasa
		nestedClassAttrCnt = 0;		//	deklaracije polja unutr klasa 
   
    
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal syntax error - ", cur_token);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void report_error(String message, Object info) {
    	semError = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol) {
            msg.append (" at row ").append(((Symbol)info).left);
            msg.append (" - unrecognized symbol '").append(((Symbol)info).value + "'");
        }
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at row ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
    public void report_debug(String message) {
    	StringBuilder msg = new StringBuilder(message); 
        log.debug(msg.toString());
    }
    
    public String objToString(Obj o) {
    	SymbolTableVisitor stv = new DumpSymbolTableVisitor();
    	
    	stv.visitObjNode(o);
    	return stv.getOutput();
    }
    
     public boolean assignableTo(Obj dst, Struct src) {
    	Struct dstType = dst.getType();
    	
    	if (src.assignableTo(dstType))
    		return true;
    	/*
		if (dstType.getKind() == Struct.Array && dstType.getElemType().equals(Tab.charType) && src.equals(StringHelper.stringType))
			return true;
		*/
		if (dstType.getKind() == Struct.Class && src.getKind() == Struct.Class)
			if (inheritanceTable.containsKey(src))
				if (inheritanceTable.get(src).contains(dstType))
					return true;
	
		return false;
	}
	
	// NIVO B
	public void checkCond(int or) {
		Code.put(Code.dup2);
		//	| left right left right
		Code.putFalseJump(Code.ne, 0);	// ako su isti idi na else
		int p = Code.pc - 2;
		
		// THEN
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.loadConst(or);			// ako su razliciti onda je sigurno false
		Code.putJump(0);
		int p2 = Code.pc - 2;
		Code.fixup(p);
		
		// ELSE
		Code.put(Code.pop);
		Code.loadConst(1);
		Code.putFalseJump(Code.eq, 0);	//ako je 0 idi na else
		p = Code.pc - 2;
		Code.loadConst(1);			// ako je 1 onda je true
		Code.putJump(0);
		int p3 = Code.pc - 2;
		Code.fixup(p);
		
		Code.loadConst(0);			// ako je 0 onda je false
		Code.fixup(p2);
		Code.fixup(p3);
	}
	

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	int constValue = 0;
	ArrayList<String> constStrings = new ArrayList<String> ();
	Obj currentMethod = null;
	Obj currentClass = null;
	Struct superClass = null;
	Obj currentDesignator = null;
	Obj currentCall = null;
	Stack<Obj> funcCalls = new Stack<Obj> ();
	Iterator<Obj> iterator = null;
	Stack<Iterator<Obj>> iterators = new Stack<Iterator<Obj>> ();
	int pos = 0;
	Stack<Integer> positions = new Stack<Integer> ();
	boolean returnFound = false;
	int fpPos = 0, actPars = 0;
	boolean isVoid = false;
	int inWhile = 0;
	
	// NIVO B
	// if else patch stack
	Stack<Integer> patch = new Stack<Integer> ();
	Stack<Integer> patch2 = new Stack<Integer> ();
	Stack<Boolean> cond = new Stack<Boolean> ();
	Stack<Integer> top = new Stack<Integer> ();
	Stack<Integer> brk = new Stack<Integer> ();
	StringHelper strHelper;
	
	// NIVO C
	// location pointer mi je zbir broja globalnih promenljivih i globalnih nizova
	ClassHelper classHelper;
	int lp = 0;

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // Mulop ::= MOD 
            {
              Integer RESULT =null;
		 RESULT = Code.rem; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // Mulop ::= DIV 
            {
              Integer RESULT =null;
		 RESULT = Code.div; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Mulop ::= MUL 
            {
              Integer RESULT =null;
		 RESULT = Code.mul; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Addop ::= MINUS 
            {
              Integer RESULT =null;
		 RESULT = Code.sub; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Addop ::= PLUS 
            {
              Integer RESULT =null;
		 RESULT = Code.add; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Relop ::= LEQ 
            {
              Integer RESULT =null;
		 RESULT = Code.le; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Relop ::= LESS 
            {
              Integer RESULT =null;
		 RESULT = Code.lt; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Relop ::= GREQ 
            {
              Integer RESULT =null;
		 RESULT = Code.ge; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Relop ::= GRE 
            {
              Integer RESULT =null;
		 RESULT = Code.gt; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Relop ::= NEQ 
            {
              Integer RESULT =null;
		 RESULT = Code.ne; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Relop ::= EQ 
            {
              Integer RESULT =null;
		 RESULT = Code.eq; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // Factor ::= LPAREN Expr RPAREN 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
		 	// NIVO A
		 	RESULT = expr; 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Factor ::= STRING 
            {
              Struct RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		 	// NIVO B
		 	// kada naidje na string konstantu "nekistring"
		 	strHelper.stringLiteral(s);
		 	RESULT = StringHelper.stringType; 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // Factor ::= BOOL 
            {
              Struct RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		 	// NIVO A
		 	Obj o = Tab.insert(Obj.Con, "", StringHelper.boolType);
			o.setAdr((b.booleanValue() ? 1 : 0));
			Code.load(o);
		 	RESULT = StringHelper.boolType; 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Factor ::= CHAR 
            {
              Struct RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character c = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		 	// NIVO A
		 	Obj o = Tab.insert(Obj.Con, "", Tab.charType);
			o.setAdr(c.charValue());
			Code.load(o);
			RESULT = Tab.charType;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Factor ::= NUMBER 
            {
              Struct RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		 	// NIVO A
		 	Obj o = Tab.insert(Obj.Con, "", Tab.intType);
			o.setAdr(n.intValue());
			Code.load(o);
			RESULT = Tab.intType; 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Factor ::= Designator 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		 	// NIVO B, proveravas je l const string, nakon ovoga na steku je njegova adresa
		 	if (desig.getKind() == Obj.Con && desig.getType() == StringHelper.stringType) {
		 		strHelper.stringLiteral(constStrings.get(desig.getAdr()));	
		 	}
		 	// NIVO A
		 	else 
		 		Code.load(desig);
		 	RESULT = desig.getType(); 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Factor ::= NEW Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
			RESULT = Tab.noType;
		 	if (type.getKind() != Struct.Class)
		 		parser.report_error("Semantics error " + typeleft + " - variable must be of a class type", null);
		 	else {
		 		ClassHelper.createInstance(type);
		 		RESULT = type;
		 	}
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Factor ::= NEW Type LBRACKET Expr RBRACKET 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
					
			RESULT = Tab.noType;
		 	if (expr.equals(Tab.intType)) {
		 		Code.put(Code.newarray);
		 		Code.put((type == Tab.intType ? 1 : 0 )); 
		 		RESULT = new Struct(Struct.Array, type);
		 	} else
		 		parser.report_error("Semantics error at row " + exprleft + " - number of elements must be an integer value", null);		 	
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Factor ::= Function 
            {
              Struct RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct func = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = func; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Term ::= Term Mulop Factor 
            {
              Struct RESULT =null;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int mulopleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int mulopright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer mulop = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int factorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int factorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct factor = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (!term.equals(Tab.intType) || !factor.equals(Tab.intType))
				parser.report_error("Semantics error at row " + factorleft + " - expression must be an integer value", null);
			else {
				Code.put(mulop);
				RESULT = term;
			}
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // Term ::= Factor 
            {
              Struct RESULT =null;
		int factorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int factorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct factor = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = factor; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Expr ::= Expr Addop NT$9 Term 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int addopleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int addopright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer addop = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		RESULT = Tab.noType;
		if (expr.equals(Tab.intType) && term.equals(Tab.intType)) {
			// NIVO A
			Code.put(addop);
			RESULT = expr;
		}
		else if (addop == Code.add) {
			if (expr.equals(StringHelper.stringType) && term.equals(StringHelper.stringType)) {
				// NIVO B
				// 		| adr1 len1 adr2
				Code.put(Code.dup);
				Code.put(Code.arraylength);
				// 		| adr1 len1 adr2 len2
				strHelper.callConcat();
				RESULT = StringHelper.stringType;
			} else
				parser.report_error("Semantics error at row " + exprleft + " - expressions must be integers or strings", null);
		} else
			parser.report_error("Semantics error at row " + exprleft + " - expressions must be integers", null);		
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // NT$9 ::= 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int addopleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int addopright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer addop = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

		if (addop == Code.add) {
			if (expr.equals(StringHelper.stringType)) {
				// NIVO B				
				// 		| adr1 
				Code.put(Code.dup);
				Code.put(Code.arraylength);
				// 		| adr1 len1
				RESULT = StringHelper.stringType;
			}
		}
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$9",71, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // Expr ::= MINUS Term 
            {
              Struct RESULT =null;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
		// NIVO A
		RESULT = Tab.noType;
		if (!term.equals(Tab.intType))
				parser.report_error("Semantics error at row " + termleft + " - expression must be an integer value", null);
		else {
			Code.put(Code.neg);
			RESULT = term;
		}
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Expr ::= Term 
            {
              Struct RESULT =null;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct term = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = term; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // DesignatorList ::= DesignatorList LBRACKET error RBRACKET 
            {
              Obj RESULT =null;
		int arrayleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int arrayright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj array = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 
					parser.report_debug("Successful error recovery - array indexing");
					
					if (array.getType().getKind() != Struct.Array) { 
                    	parser.report_error("Semantics error at row " + arrayleft + " - expected an array",null);
                    	RESULT = Tab.noObj;
                    } else {
                    	RESULT = new Obj (Obj.Elem, array.getName(), array.getType().getElemType());
                    } 
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // DesignatorList ::= IDENT 
            {
              Obj RESULT =null;
		int identleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int identright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String ident = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
					if (ident.equals(parser.classThis) && parser.inClass) {							 			
						RESULT = currentClass;
					} else {
						Obj o = Tab.find(ident);
						if (o != Tab.noObj) {
							// parser.report_info("Use of " + parser.objToString(o) + " at row " + identleft,null);		
						} else {
	                    	parser.report_error("Semantics error at row " + identleft + " - symbol '" + ident + "' not found",null);					
						}
						RESULT = o;
					}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // DesignatorList ::= DesignatorList LBRACKET NT$8 Expr RBRACKET 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int arrayleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int arrayright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj array = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					if (!expr.equals(Tab.intType))
					 	parser.report_error("Semantics error at row " + exprleft + " - array index must be an integer value", null);		 	
                    else if (array.getType().getKind() == Struct.Array) {                     	
                    	RESULT = new Obj (Obj.Elem, array.getName(), array.getType().getElemType());
                    }
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // NT$8 ::= 
            {
              Obj RESULT =null;
		int arrayleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int arrayright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj array = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

					RESULT = Tab.noObj;
					if (array.getType().getKind() != Struct.Array) { 
                    	parser.report_error("Semantics error at row " + arrayleft + " - expected an array",null);                  	
                    } else {
					 	Code.load(array); 		
                    }
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",70, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // DesignatorList ::= DesignatorList STOP IDENT 
            {
              Obj RESULT =null;
		int clleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int clright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj cl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int fieldleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int fieldright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String field = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					if (cl.getType().getKind() != Struct.Class) { 
                    	parser.report_error("Semantics error at row " + clleft + " - expected a class",null);
                    	RESULT = Tab.noObj;
                    } else {
                    	Obj o = cl.getType().getMembers().searchKey(field);
	                    if (o == null) {
	                    	o = Tab.noObj;
	                    	parser.report_error("Semantics error at row " + clleft + " - class attribute '" + field + "' doesn't exist",null);
	                    } else {
	                    	// NIVO C
	                    	// naisli smo na this i sigurno smo u pozivu metode
	                    	if (cl.getKind() == Obj.Type) {
	                    		Code.put(Code.load_n + 0);
	                    	}	                    	
	                    	else
	                    		Code.load(cl);
	                    	// parser.report_info("Use of " + parser.objToString(o) + " at row " + clleft,null);
	                     }
	                    RESULT = o;
                    }     
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // Designator ::= DesignatorList 
            {
              Obj RESULT =null;
		int dlistleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dlistright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj dlist = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = dlist; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // NumberOpt ::= 
            {
              Integer RESULT =null;
		 RESULT = -1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumberOpt",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // NumberOpt ::= COMMA NUMBER 
            {
              Integer RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = n; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumberOpt",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // PrintStatement ::= PRINT LPAREN Expr NumberOpt RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
							
					if (expr != Tab.intType && expr != Tab.charType && expr != StringHelper.boolType && expr != StringHelper.stringType)
						parser.report_error("Semantics error at row " + exprleft + " - parameter must be an integer/character/boolean or a string value", null);							
					else {
						 if (expr == Tab.intType) {
						 	Code.loadConst((n.intValue() == -1 ? 5 : n.intValue()));
					  	 	Code.put(Code.print);
					  	 } 
					  	 if (expr == Tab.charType) {
					  	 	Code.loadConst((n.intValue() == -1 ? 1 : n.intValue()));
					  	 	Code.put(Code.bprint);
					  	 }
					  	 // NIVO B
					  	 if (expr == StringHelper.stringType) {
						  	 //		| adr
						  	 Code.put(Code.dup);
						  	 Code.put(Code.arraylength);
						  	 //		| adr len
					  	 	 strHelper.callPrints();					  	 
						 }
					}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("PrintStatement",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // ReadStatement ::= READ LPAREN Designator RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
							
					if (desig != null)
						if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
							parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be a variable", null);
						} else {
							if (desig.getType() != Tab.intType && desig.getType() != Tab.charType && desig.getType() != StringHelper.boolType && desig.getType() != StringHelper.stringType)
								parser.report_error("Semantics error at row " + desigleft + " - parameter must be an integer/character/boolean or a string value", null);							
							else {
								 if (desig.getType() == Tab.intType) {
							  	 	Code.put(Code.read);
							  	 }
							  	 if (desig.getType() == Tab.charType) {
							  	 	Code.put(Code.bread);	
							  	 }
							  	 // NIVO B
							  	 if (desig.getType() == StringHelper.stringType) {
							  	 	strHelper.callReads();
							  	 }
							  	 Code.store(desig);
							}
						}
					// else
						// parser.report_error("Desig je null", null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReadStatement",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // ReturnStatement ::= RETURN Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			    	returnFound = true;
			    	Struct currMethType = currentMethod.getType();
			    	if (isVoid)
			    		parser.report_error("Semantics error at row " + exprleft + " - function does not need a return value", null);
			    	else if (!expr.compatibleWith(currMethType))
			    		parser.report_error("Semantics error at row " + exprleft + " - return types are not compatible", null);
			    	else {
			    		Code.put(Code.exit);
						Code.put(Code.return_);
					}
			    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnStatement",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // ReturnStatement ::= RETURN SEMI_COMMA 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					returnFound = true;
				 	Struct currMethType = currentMethod.getType();
				 	if (!isVoid) {
				 		parser.report_error("Semantics error at row " + dummyleft + " - function missing a return value", null);
				 	}	 
			    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnStatement",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // CondFact ::= Expr Relop Expr 
            {
              Struct RESULT =null;
		int typeLleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeLright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct typeL = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int typeRleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeRright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct typeR = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (typeL == strHelper.stringType || typeR == strHelper.stringType || typeL.getKind() == Struct.Class || typeR.getKind() == Struct.Class) {
				if (op != Code.ne && op != Code.eq)
					parser.report_error("Semantics error at row " + typeLleft + " - operator in condition expression is not allowed for class/array types", null);
				else {
					if (!typeL.compatibleWith(typeR))
						parser.report_error("Semantics error at row " + typeLleft + " - incompatible types", null);
					else {
						if (typeL == strHelper.stringType) {
							//		| adr1 adr2
							Code.put(Code.dup2);
							Code.put(Code.pop);
							Code.put(Code.arraylength);
							//		| adr1 adr2 len1
							Code.put(Code.dup2);
							Code.put(Code.pop);
							Code.put(Code.arraylength);
							//		| adr1 adr2 len1 len2
							strHelper.callCmpStr();
							//		| rezultat
						}
						RESULT = StringHelper.boolType;
					}
				}
			}
			else {
				if (!typeL.compatibleWith(typeR))
					parser.report_error("Semantics error at row " + typeLleft + " - incompatible types", null);
				else {
					// NIVO B
					Code.putFalseJump(op, 0);	// ako je netacno idi na else
					int p = Code.pc - 2;
					Code.loadConst(1);			// ako je tacno postavi 1 na stek
					Code.putJump(0);
					int p2 = Code.pc - 2;
					Code.fixup(p);
					Code.loadConst(0);			// ako je netacan uslov postavi 0 na stek
					Code.fixup(p2);
					
					RESULT = StringHelper.boolType;
				}
			}		
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // CondFact ::= Expr 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = expr; // vec ucitano na stek preko expr 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // CondTerm ::= CondTerm AND CondFact 
            {
              Struct RESULT =null;
		int typeLleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeLright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct typeL = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeRleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeRright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct typeR = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (typeL.equals(StringHelper.boolType) && typeR.equals(StringHelper.boolType)) {
				// treba da proveris prvo da li su razliciti
				// ako jesu onda je sigurno false
				// ako su isti treba da proveris vrednost bar jednog da l' je 1				
				parser.checkCond(0);
				
				RESULT = StringHelper.boolType;
			}
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // CondTerm ::= CondFact 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = type; // vec ucitano na stek preko CondFact 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // ConditionCheck ::= CondTerm 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  	RESULT = Tab.noType;
				if (type.equals(StringHelper.boolType))
					RESULT = StringHelper.boolType;
				// vec ucitano na stek preko CondTerm
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionCheck",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // ConditionCheck ::= ConditionCheck OR CondTerm 
            {
              Struct RESULT =null;
		int typeLleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeLright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct typeL = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeRleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeRright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct typeR = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  	RESULT = Tab.noType;
				if (typeL.equals(StringHelper.boolType) && typeR.equals(StringHelper.boolType)) {
					// treba da proveris prvo da li su razliciti
					// ako jesu onda je sigurno true
					// ako su isti treba da proveris vrednost bar jednog da l' je 1
					parser.checkCond(1);
								
					RESULT = StringHelper.boolType;
				}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionCheck",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // Condition ::= error 
            {
              Struct RESULT =null;
		 
				cond.push(new Boolean(false));
				parser.report_debug("Successful error recovery - condition of an if/while construction"); 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // Condition ::= ConditionCheck 
            {
              Struct RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct result = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				if (!result.equals(StringHelper.boolType)) {
					cond.push(new Boolean(false));
					parser.report_error("Semantics error at row " + resultleft + " - expression must be a boolean value", null);				
				} else {
					Code.loadConst(1);
					Code.putFalseJump(Code.eq, 0);
					patch.push(new Integer(Code.pc - 2));
					cond.push(new Boolean(true));
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // BreakStatement ::= BREAK SEMI_COMMA 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					if (inWhile == 0)
						parser.report_error("Semantics error at row " + dummyleft + " - 'break' statement can only be used inside a while loop", null);
					else {
						Code.putJump(0);
						brk.push(new Integer(Code.pc - 2));
						brk.push(new Integer(inWhile));
					}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BreakStatement",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // WhileTerm ::= WHILE 
            {
              Object RESULT =null;
		 
			top.push(new Integer(Code.pc));
			inWhile++; 
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("WhileTerm",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // UnmatchedWhileStatement ::= WhileTerm LPAREN Condition RPAREN Unmatched 
            {
              Object RESULT =null;
		 
							Code.putJump(top.pop());
							if (cond.pop().booleanValue()) Code.fixup(patch.pop());
							if ((brk.size() > 0) && (brk.peek().intValue() == inWhile)) {
								brk.pop();
								Code.fixup(brk.pop());
							}
							inWhile--; 
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("UnmatchedWhileStatement",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // MatchedWhileStatement ::= WhileTerm LPAREN Condition RPAREN Matched 
            {
              Object RESULT =null;
		 
							Code.putJump(top.pop());
							if (cond.pop().booleanValue()) Code.fixup(patch.pop());
							if ((brk.size() > 0) && (brk.peek().intValue() == inWhile)) {
								brk.pop();
								Code.fixup(brk.pop());
							}
							inWhile--; 
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MatchedWhileStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // IfTerm ::= IF 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IfTerm",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // IfMatched ::= IfTerm LPAREN Condition RPAREN Matched ELSE 
            {
              Object RESULT =null;
		
		  		if (cond.peek().booleanValue()) {
			  		Code.putJump(0);
					patch2.push(new Integer(Code.pc - 2));
					Code.fixup(patch.pop());
				}
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IfMatched",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // UnmatchedIfStatement ::= IfMatched Unmatched 
            {
              Object RESULT =null;
		 if (cond.pop().booleanValue()) Code.fixup(patch2.pop()); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("UnmatchedIfStatement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // UnmatchedIfStatement ::= IfTerm LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;
		 if (cond.pop().booleanValue()) Code.fixup(patch.pop()); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("UnmatchedIfStatement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // MatchedIfStatement ::= IfMatched Matched 
            {
              Object RESULT =null;
		 if (cond.pop().booleanValue()) Code.fixup(patch2.pop()); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MatchedIfStatement",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // ActPars ::= ActPars COMMA Expr 
            {
              Struct RESULT =null;
		int actParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int actParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct actPars = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (currentCall != null) {
				if (currentCall.getLevel() > pos) {
					// NIVO C
					// ako je poziv metode mora u ispisu da se umanji brojac za jedan
					int p;
					if (currentCall.getFpPos() == -1) {
						classHelper.dummyCall();
						p = pos;
					}
					else
						p = pos + 1;
					if (!iterator.next().getType().compatibleWith(expr))
						parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + p + ". parameter", null);
					else
						RESULT = expr;
					// NIVO C
					classHelper.dummyCall();
					pos++;
				} else 
					parser.report_error("Semantics error at row " + exprleft + " - number of parameters doesn't match", null);	
			} // else
				// parser.report_error("Current call je null", null);	
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // ActPars ::= Expr 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			RESULT = Tab.noType;
			if (currentCall != null) {
				if (currentCall.getLevel() > pos) {
					// NIVO C
					// ako je poziv metode mora u ispisu da se umanji brojac za jedan
					int p;
					if (currentCall.getFpPos() == -1) {
						classHelper.dummyCall();
						p = pos;
					}
					else
						p = pos + 1;
					if (currentCall.getName().equals("len")) {
						if (expr.getKind() != Struct.Array)
							parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + p + ". parameter", null);
						else
							RESULT = expr;
					} else {
						if (!iterator.next().getType().compatibleWith(expr))
							parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + p + ". parameter", null);
						else
							RESULT = expr;
					}
					pos++;
				} else 
					parser.report_error("Semantics error at row " + exprleft + " - number of parameters doesn't match", null);	
			} // else 
				// parser.report_error("Current call je null", null);	
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // Function ::= Designator LPAREN error RPAREN 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 parser.report_debug("Successful error recovery - actual parameters list"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Function",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // Function ::= Designator LPAREN RPAREN 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
			 if (parser.inMain) 
					parser.callCnt++;

				RESULT = Tab.noType;
				if (desig != null) {
			 		if (desig.getKind() != Obj.Meth)
			 			parser.report_error("Semantics error at row " + desigleft + " - variable must be a global function or a class method", null);
			 		else {
							if (desig.getLevel() > 0)
								if (desig.getLevel() > 1 && desig.getFpPos() != -1)
									parser.report_error("Semantics error at row " + desigleft + " - function '" + desig.getName() + "' missing parameters", null);
							else {
								RESULT = desig.getType();
								// NIVO B
								if (desig.getFpPos() != - 1) {
									int dest_adr = desig.getAdr() - Code.pc; // relativna adresa
									Code.put(Code.call); 
									Code.put2(dest_adr);
								} else {
									// NIVO C
									//		| adrobj
									Code.put(Code.dup);
									Code.put(Code.getfield);
									Code.put2(0);
									//		| adrobj adrvtab
									Code.put(Code.invokevirtual);
									String methName = desig.getName();
									for (int i = 0; i < methName.length(); i++)
										Code.put4(methName.charAt(i));
									Code.put4(-1);
								}			
							}
						}
			 	} // else
			 		// parser.report_error("Desig je null", null);
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Function",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // Function ::= Designator LPAREN NT$7 ActPars RPAREN 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String dummy = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = Tab.noType;
			if (currentCall != null) {
				RESULT = currentCall.getType();
				if (currentCall.getLevel() > pos)
			 			parser.report_error("Semantics error at row " + dummyleft + " - function '" + currentCall.getName() + "' missing parameters", null);										
				
				// NIVO B
				if (currentCall.getFpPos() != - 1) {
					int dest_adr = currentCall.getAdr() - Code.pc; // relativna adresa
					Code.put(Code.call); 
					Code.put2(dest_adr);
				} else {
					// NIVO C
					Code.put(Code.getfield);
					Code.put2(0);
					//		| adrobj par1 par2 ... parn adrvtab
					Code.put(Code.invokevirtual);
					String methName = currentCall.getName();
					for (int i = 0; i < methName.length(); i++)
						Code.put4(methName.charAt(i));
					Code.put4(-1);
				
				}
				
				if (funcCalls.size() > 0) {
					currentCall = funcCalls.pop();
					iterator = iterators.pop();
					pos = positions.pop();
				} else {
					currentCall = null;
					iterator = null;
					pos = 0;
				}
		 	} // else
		 		// parser.report_error("Current call je null", null);
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Function",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // NT$7 ::= 
            {
              Struct RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

		 	if (parser.inMain) 
				parser.callCnt++;
				
		 	if (desig != null) {
		 		if (desig.getKind() != Obj.Meth)
		 			parser.report_error("Semantics error at row " + desigleft + " - variable must be a global function or a class method", null);
		 		else {
		 			if (currentCall != null) {
							funcCalls.push(currentCall);
							iterators.push(iterator);
							positions.push(pos);
					}
					currentCall = desig;
					iterator = currentCall.getLocalSymbols().iterator();
					pos = 0;
					if (currentCall.getLevel() <= 0)
			 			parser.report_error("Semantics error at row " + desigleft + " - function doesn't need parameters", null);					
					
					// NIVO C
					//		| adrKlase
					if (currentCall.getFpPos() == - 1) {
						pos++;
						iterator.next();
						Code.put(Code.dup);
					//		| adrKlase adrKlase
					}
				}
		 	} // else
		 		// parser.report_error("Desig je null", null);
		 	
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",69, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // FunctionCall ::= Function SEMI_COMMA 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FunctionCall",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // IncDec ::= DEC 
            {
              Integer RESULT =null;
		 RESULT = -1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IncDec",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // IncDec ::= INC 
            {
              Integer RESULT =null;
		 RESULT = Code.inc; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IncDec",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // SideEffect ::= Designator IncDec SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				// NIVO A
				if (desig != null) {
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
					} else {
						if (!desig.getType().equals(Tab.intType))
							parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
						else {
							Code.load(desig);
							Code.loadConst(1);
							if (op == Code.inc) {
								Code.put(Code.add);
							} else {
								Code.put(Code.sub);
							}
							Code.store(desig);
						}
					}
				} // else
					// parser.report_error("Desig je null", null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("SideEffect",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // Assignment ::= Designator EQUALS error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - value assignment"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // Assignment ::= Designator EQUALS Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
			
				// NIVO A		
				if (desig != null) {
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be a variable", null);
						desig = Tab.noObj;
					}
					// menjano
	 				if (!parser.assignableTo(desig, expr))
	 					parser.report_error("Semantics error at row " + desigleft + " - incompatible types", null);
	 				else
	 					Code.store(desig);	 	
				} // else
					// parser.report_error("Desig je null", null);
						
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // ExprStatement ::= FunctionCall 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // ExprStatement ::= SideEffect 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // ExprStatement ::= Assignment 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // Matched ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
		 parser.blockCnt++; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Matched ::= PrintStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Matched ::= ReadStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Matched ::= ReturnStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Matched ::= BreakStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Matched ::= MatchedWhileStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Matched ::= MatchedIfStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Matched ::= ExprStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Unmatched ::= UnmatchedWhileStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Unmatched ::= UnmatchedIfStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Statement ::= Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Statement ::= Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // FormPar ::= Type error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - formal parameter declaration"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // FormPar ::= Type IDENT BracketsOpt 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int parNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int parNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String parName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 					
				parser.formParCnt++;
				
				Obj o = Tab.currentScope().findSymbol(parName);
	 			if (o == null && !parName.equals("this")) {
	 				if (!brack.booleanValue())
	 					o = Tab.insert(Obj.Var, parName, type);
	 				else
	 					o = Tab.insert(Obj.Var, parName, new Struct(Struct.Array, type));
	 				o.setFpPos(fpPos);
	 				fpPos++;
	 				// parser.report_info("Formal parameter '" + parName + "' declaration at row " + parNameleft, null);
	 			} else if (!parName.equals("this")) {
	 				parser.report_error("Semantics error at row " + parNameleft + " - multiple definition of '" + parName + "'", null);
	 			} else {
	 				parser.report_error("Semantics error at row " + parNameleft + " - 'this' cannot be a formal parameter", null);
	 			}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FormPars ::= FormPar 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // FormPars ::= error COMMA FormPar 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - formal parameter declaration"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // FormPars ::= FormPars COMMA FormPar 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FormParsOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsOpt",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // FormParsOpt ::= FormPars 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsOpt",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // ReturnType ::= VOID 
            {
              Struct RESULT =null;
		 isVoid = true; RESULT = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // ReturnType ::= Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 isVoid = (type == Tab.noType); RESULT = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // MethodDecl ::= ReturnType IDENT NT$5 LPAREN FormParsOpt RPAREN LocalVarDeclList LBRACE NT$6 StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String dummy = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			   	  if (parser.inMain && fpPos > 0)
					parser.report_error("Semantics error at row " + methNameleft + " - 'main' function cannot have parameters", null);
					
			   	  // da li brojimo i main u funkcije
			   	  parser.method = false;
			   	  parser.blockCnt++;
			   	  if (!parser.inClass) 
			   	  	parser.functionCnt++;
			   	  else 
			   	  	parser.nestedClassMethodCnt++;
			   	  if (parser.inMain) 
			   	  	parser.inMain = false;
			   	  	
			   	  if (!returnFound && !isVoid)
			   	 	parser.report_error("Semantics error at row " + dummyleft + " - function '" + methName + "' missing 'return' statement", null);
			   	  
			   	  Tab.chainLocalSymbols(currentMethod);
			   	  Tab.closeScope();
			   	  
			   	  // NIVO A
			   	  if (isVoid) {
				   	  Code.put(Code.exit);
					  Code.put(Code.return_);
				  } else {
				  // generise trap ako se zaobidje return
					  Code.put(Code.trap); 
					  Code.put(1);
				  }

			   	  returnFound = isVoid = false;
				  currentMethod = null;
				  fpPos = 0;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;

			   	  // NIVO A
			   	  currentMethod.setLevel(fpPos);
			   	  currentMethod.setAdr(Code.pc);
			   	  if (parser.inMain) {
			   		Code.mainPc = currentMethod.getAdr();
			   	  }
			   	  Code.put(Code.enter);
			   	  Code.put(currentMethod.getLevel());
			   	  Code.put(Tab.currentScope().getnVars());
			   	  
			   	  // NIVO C
			   	  if (parser.inMain)
				  	lp = ClassHelper.allocVTables(parser.globalVarCnt + parser.globalArrayCnt);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // NT$5 ::= 
            {
              Object RESULT =null;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
			   	  parser.method = true; 
			   	  if (!parser.inClass && methName.equals("main")) 
			   	  	parser.inMain = true;
			   	  
			   	  Obj o = Tab.currentScope().findSymbol(methName);
				  if (o == null) {
		 				currentMethod = Tab.insert(Obj.Meth, methName, retType);
		 				// parser.report_info("Function '" + methName + "' definition at row " + methNameleft, null);
		 		  } else {
		 		  		currentMethod = o;
		 		  		if (!((superClass != null) && (superClass.getMembers().searchKey(methName) != null)))
		 					parser.report_error("Semantics error at row " + methNameleft + " - multiple definition of a function '" + methName + "'", null);
		 		  		else {
		 		  			// parser.report_info("Class method '" + methName + "' redefinition at row " + methNameleft, null);
		 		  		}
		 		  }	 
			   	  Tab.openScope();
			   	  
			   	  // NIVO C
			   	  if (parser.inClass) {
			   	  	currentMethod.setFpPos(-1);
			   	  	o = Tab.insert(Obj.Var, "this", currentClass.getType());
			   	  	o.setFpPos(fpPos++);
			   	  }
			   	  
			   	  if (parser.inMain && !isVoid)
			   	  	parser.report_error("Semantics error at row " + methNameleft + " - function '" + methName + "' must be VOID", null);  	   
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // Methods ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Methods",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // Methods ::= LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Methods",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // Extends ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // Extends ::= EXTENDS error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - class inheritance"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // Extends ::= EXTENDS Type 
            {
              Object RESULT =null;
		int outerClassleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int outerClassright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct outerClass = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				if (!(outerClass.getKind() == Struct.Class))
					parser.report_error("Semantics error at row " + outerClassleft + " - outer class must be of a class type", null);
				else if (outerClass == currentClass.getType())
					parser.report_error("Semantics error at row " + outerClassleft + " - class cannot inherit itself", null);
				else {
					// parser.report_info("Class inheritance at row " + outerClassleft, null);
					superClass = outerClass;
					Iterator<Obj> exIter = superClass.getMembers().symbols().iterator();
					Obj o = null;
					for (int i = 0; i < superClass.getNumberOfFields(); i++) {
						o = exIter.next();
						if (o.getKind() == Obj.Fld) {
							Obj o1 = null;
							if ((o.getType().getKind() != Struct.Array) || (o.getType() == strHelper.stringType))
				 				o1 = Tab.insert(o.getKind(), o.getName(), o.getType());
			 				else
			 					o1 = Tab.insert(o.getKind(), o.getName(), new Struct(Struct.Array, o.getType().getElemType()));
							// NIVO C
							o1.setAdr(o1.getAdr() + 1);
						}
					}
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // ClassDecl ::= CLASS IDENT NT$2 Extends LBRACE NT$3 LocalVarDeclList NT$4 Methods RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		 
			  	parser.inClass = false; 
			  	parser.nestedClassCnt++;
			  	Tab.chainLocalSymbols(currentClass.getType());
			   	Tab.closeScope();
			   	
			   	// NIVO C
			   	ClassHelper.classDefs.put(currentClass.getType(), currentClass);
			   	
			   	currentClass = null;
			   	superClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // NT$4 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
 
			  	parser.attrDef = false; 
			  	currentClass.getType().setMembers(Tab.currentScope().getLocals());
			  	if (superClass != null) {
			  		Iterator<Obj> exIter = superClass.getMembers().symbols().iterator();
					Obj meth = null;
					Obj o = null;
					while (exIter.hasNext()) {
						meth = exIter.next();
						if (meth.getKind() == Obj.Meth) {
			 				o = Tab.insert(Obj.Meth, meth.getName(), meth.getType());
			 				Tab.openScope();
			 				Iterator<Obj> methIter = meth.getLocalSymbols().iterator();
			 				int i = 0;
			 				while (methIter.hasNext()) {
			 					Obj par = methIter.next();
			 					if ((par.getType().getKind() != Struct.Array)  || (par.getType() == strHelper.stringType))
				 					par = Tab.insert(Obj.Var, par.getName(), par.getType());
				 				else
				 					par = Tab.insert(Obj.Var, par.getName(), new Struct(Struct.Array, par.getType().getElemType()));
				 				if (i < meth.getLevel())
				 					par.setFpPos(i++);		
			 				}
			 				Tab.chainLocalSymbols(o);
			 				Tab.closeScope();
			 				// NIVO C
			 				o.setLevel(i);
			 				o.setFpPos(-1);
			 				o.setAdr(meth.getAdr());
						}
					}
			  	}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // NT$3 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
 
			  	parser.attrDef = true;
			  	if (superClass != null) {
			  		ArrayList<Struct> list = new ArrayList<Struct> ();
					list.add(superClass);
					if (parser.inheritanceTable.containsKey(superClass)) {
						list.addAll(parser.inheritanceTable.get(superClass));
					}
					parser.inheritanceTable.put(currentClass.getType(), list);
				}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$2 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
			  	parser.inClass = true;
			  	
			  	Obj o = Tab.find(className);
			  	if (o == Tab.noObj) {
	 				currentClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
	 				// parser.report_info("Class '" + className + "' definition at row " + classNameleft, null);
	 			} else {
	 				currentClass = o;
	 				parser.report_error("Semantics error at row " + classNameleft + " - multiple definition of a class '" + className + "'", null);
	 			}
	 			Tab.openScope();		  		
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // BracketsOpt ::= 
            {
              Boolean RESULT =null;
		 
			 	RESULT = new Boolean(false);
			   	if (!parser.method && !parser.inClass) 
			   		parser.globalVarCnt++; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BracketsOpt",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // BracketsOpt ::= LBRACKET RBRACKET 
            {
              Boolean RESULT =null;
		 
			 	RESULT = new Boolean(true);
			 	if (!parser.method && !parser.inClass) 
			 		parser.globalArrayCnt++; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BracketsOpt",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // LocalVariable ::= IDENT BracketsOpt 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 	
				// brojimo samo lokalne u main funkciji
				if (parser.inMain)
					parser.localVarCnt++;
				else if (parser.inClass && parser.attrDef) 
					parser.nestedClassAttrCnt++;
	 			
	 				if (parser.attrDef) {
	 					Obj o = Tab.currentScope().findSymbol(varName);
	 					if (o == null && !varName.equals(parser.classThis)) {
		 					if (!brack.booleanValue())
			 					o = Tab.insert(Obj.Fld, varName, parser.type);
		 					else
		 						o = Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, parser.type));
		 					o.setAdr(o.getAdr() + 1);
		 					// parser.report_info("Class attribute '" + varName + "' declaration at row " + varNameleft, null);
	 					} else if (!varName.equals(parser.classThis)) {
	 						if ((superClass != null) && (superClass.getMembers().searchKey(varName) != null)) {
	 							int adr = o.getAdr();
	 							Tab.currentScope().getLocals().deleteKey(varName);
	 							if (!brack.booleanValue())
				 					o = Tab.insert(Obj.Fld, varName, parser.type);
			 					else
			 						o = Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, parser.type));
	 							o.setAdr(adr);
	 							// parser.report_info("Class attribute '" + varName + "' redefinition at row " + varNameleft, null);
	 						} else
	 							parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of a class attribute '" + varName + "'", null);				
	 					} else {
	 						parser.report_error("Semantics error at row " + varNameleft + " - 'this' cannot be a class attribute", null);				
	 					}
	 				} else {
	 					Obj o = Tab.currentScope().findSymbol(varName);
 						if (o == null && !varName.equals(parser.classThis)) {
		 					if (!brack.booleanValue())
			 					Tab.insert(Obj.Var, varName, parser.type);
		 					else
		 						Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
		 					// parser.report_info("Local variable '" + varName + "' declaration at row " + varNameleft, null);
		 				} else if (!varName.equals(parser.classThis)) {
		 					parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of a local variable '" + varName + "'", null);
		 				} else {
			 				parser.report_error("Semantics error at row " + varNameleft + " - 'this' cannot be a local variable", null);
			 			}
	 				}	
	 			
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVariable",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // LocalVarList ::= LocalVariable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // LocalVarList ::= LocalVarList COMMA LocalVariable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // LocalVarDecl ::= Type error 
            {
              Object RESULT =null;
		 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration");
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // LocalVarDecl ::= Type error SEMI_COMMA 
            {
              Object RESULT =null;
		 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration"); 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // LocalVarDecl ::= Type NT$1 LocalVarList SEMI_COMMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // NT$1 ::= 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 parser.type = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // Variable ::= IDENT BracketsOpt 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 	
	 			Obj o = Tab.find(varName);
	 			if (o == Tab.noObj && !varName.equals(parser.classThis)) {
	 				if (!brack.booleanValue())
		 				Tab.insert(Obj.Var, varName, parser.type);
	 				else
	 					Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
	 				// parser.report_info("Global variable '" + varName + "' declaration at row " + varNameleft, null);	
	 			} else if (!varName.equals(parser.classThis)) {
	 				parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of '" + varName + "'", null);
	 			} else {
	 				parser.report_error("Semantics error at row " + varNameleft + " - 'this' cannot be a global variable", null);
	 			}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Variable",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // VarList ::= Variable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // VarList ::= error COMMA Variable 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - global variable definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VarList ::= VarList COMMA Variable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VarDecl ::= VarType error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - global variable definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VarDecl ::= VarType VarList SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // Constant ::= IDENT EQUALS error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - value assignment (constant)"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Constant",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // Constant ::= IDENT EQUALS ConstType 
            {
              Object RESULT =null;
		int constNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int constNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String constName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int constTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int constTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct constType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				Obj o = Tab.find(constName);
	 			if (o == Tab.noObj && !constName.equals(parser.classThis)) {
	 				o = Tab.insert(Obj.Con, constName, parser.type);
	 				o.setAdr(constValue);
	 				constValue = 0;
	 				parser.globalConstCnt++;
	 				// parser.report_info("Constant '" + constName + "' declaration at row " + constNameleft, null);
	 			} else if (!constName.equals(parser.classThis)) {
	 				parser.report_error("Semantics error at row " + constNameleft + " - multiple definition of '" + constName + "'", null);
	 			} else {
	 				parser.report_error("Semantics error at row " + constNameleft + " - 'this' cannot be a constant variable", null);
	 			}
	 			
	 			if (!o.getType().compatibleWith(constType))
	 				parser.report_error("Semantics error at row " + constNameleft + " - incompatible types", null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Constant",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ConstList ::= Constant 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ConstList ::= error COMMA Constant 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // ConstList ::= ConstList COMMA Constant 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // ConstDecl ::= CONST error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // ConstDecl ::= CONST VarType error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // ConstDecl ::= CONST VarType ConstList SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
		Obj typeNode = Tab.find(typeName);
		if (typeNode == Tab.noObj) {
			parser.report_error("Semantics error at row " + typeNameleft + " - type '" + typeName + "' not found in symbol table", null);
			RESULT = Tab.noType;
		}
		else {
			if (Obj.Type == typeNode.getKind()) {
				RESULT = typeNode.getType();
			}
			else {
				parser.report_error("Semantics error at row " + typeNameleft + " - name '" + typeName + "' doesn't represent a type", null);
				RESULT = Tab.noType;
			}
		}
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // VarType ::= Type 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.type = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarType",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ConstType ::= STRING 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				RESULT = StringHelper.stringType; 
				constStrings.add(val);
				constValue = constStrings.size() - 1; 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // ConstType ::= BOOL 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean val = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				RESULT = StringHelper.boolType; 
				if (val.booleanValue())
					constValue = 1; 
				else
					constValue = 0;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ConstType ::= CHAR 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character val = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = Tab.charType; constValue = val; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ConstType ::= NUMBER 
            {
              Struct RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer val = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = Tab.intType; constValue = val; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // MethodDeclList ::= MethodDeclList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // LocalVarDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // LocalVarDeclList ::= LocalVarDeclList LocalVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // List ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // List ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // List ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Lists ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Lists",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Lists ::= Lists List 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Lists",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // ProgramName ::= IDENT 
            {
              Obj RESULT =null;
		int progNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int progNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String progName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				strHelper = new StringHelper ();
				classHelper = new ClassHelper ();
				
				// NIVO B
				strHelper.declareFunction("chr");
				strHelper.declareFunction("ord");
				strHelper.declareFunction("len");
				strHelper.declarePrints();
				strHelper.declareReads();
				strHelper.declareCmpStr();
				strHelper.declareConcat();
				
				// NIVO C
				classHelper.declareDummyCall();
			
				RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
				Tab.openScope();
				// parser.report_info("PARSING the program '" + progName + "' at row " + progNameleft, null);				
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgramName",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // Program ::= PROGRAM ProgramName Lists LBRACE NT$0 MethodDeclList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String dummy = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			// NIVO A
			//Code.dataSize = Tab.currentScope().getnVars();
			// NIVO C
			Code.dataSize = lp;
			
			Tab.chainLocalSymbols(p);
			Obj o = Tab.find("main");
			if (o == Tab.noObj || o.getKind() != Obj.Meth)
				parser.report_error("Semantics error at row " + dummyleft + " - program missing 'main' function", null);
			Tab.closeScope();
			
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // NT$0 ::= 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;


		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

