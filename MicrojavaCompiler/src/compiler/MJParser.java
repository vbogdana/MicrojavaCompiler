
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Tue Jan 26 02:47:15 CET 2016
//----------------------------------------------------

package compiler;

import java_cup.runtime.*;
import java.util.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.DumpSymbolTableVisitor;
import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Tue Jan 26 02:47:15 CET 2016
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\221\000\002\002\010\000\002\002\004\000\002\071" +
    "\003\000\002\003\004\000\002\003\002\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\065\004\000" +
    "\002\065\002\000\002\020\004\000\002\020\002\000\002" +
    "\005\006\000\002\005\006\000\002\005\005\000\002\006" +
    "\005\000\002\006\005\000\002\006\003\000\002\007\005" +
    "\000\002\007\005\000\002\074\003\000\002\074\003\000" +
    "\002\074\003\000\002\074\003\000\002\010\003\000\002" +
    "\075\003\000\002\011\005\000\002\011\005\000\002\012" +
    "\005\000\002\012\005\000\002\012\003\000\002\013\004" +
    "\000\002\066\005\000\002\066\005\000\002\066\004\000" +
    "\002\067\005\000\002\067\003\000\002\070\004\000\002" +
    "\077\004\000\002\077\002\000\002\104\002\000\002\105" +
    "\002\000\002\106\002\000\002\014\014\000\002\015\004" +
    "\000\002\015\004\000\002\015\002\000\002\016\003\000" +
    "\002\016\002\000\002\017\005\000\002\107\002\000\002" +
    "\021\014\000\002\076\003\000\002\076\003\000\002\022" +
    "\003\000\002\022\002\000\002\023\005\000\002\023\005" +
    "\000\002\023\003\000\002\024\005\000\002\024\004\000" +
    "\002\025\004\000\002\025\002\000\002\026\003\000\002" +
    "\026\003\000\002\030\007\000\002\030\011\000\002\030" +
    "\003\000\002\027\003\000\002\027\011\000\002\027\003" +
    "\000\002\027\003\000\002\027\003\000\002\027\003\000" +
    "\002\027\003\000\002\027\005\000\002\031\003\000\002" +
    "\031\003\000\002\031\003\000\002\100\006\000\002\100" +
    "\006\000\002\101\005\000\002\102\003\000\002\102\003" +
    "\000\002\103\007\000\002\103\007\000\002\040\003\000" +
    "\002\040\002\000\002\041\005\000\002\041\003\000\002" +
    "\072\003\000\002\073\005\000\002\073\006\000\002\073" +
    "\003\000\002\073\006\000\002\042\004\000\002\042\005" +
    "\000\002\044\004\000\002\044\002\000\002\045\004\000" +
    "\002\046\005\000\002\046\003\000\002\046\003\000\002" +
    "\047\005\000\002\047\003\000\002\050\004\000\002\051" +
    "\003\000\002\051\002\000\002\052\004\000\002\032\007" +
    "\000\002\033\007\000\002\034\004\000\002\035\005\000" +
    "\002\053\003\000\002\053\002\000\002\036\007\000\002" +
    "\037\010\000\002\054\004\000\002\054\002\000\002\055" +
    "\004\000\002\056\004\000\002\056\002\000\002\057\004" +
    "\000\002\060\004\000\002\060\003\000\002\060\003\000" +
    "\002\060\003\000\002\060\003\000\002\060\007\000\002" +
    "\060\004\000\002\060\005\000\002\061\005\000\002\061" +
    "\005\000\002\061\002\000\002\062\003\000\002\062\003" +
    "\000\002\062\003\000\002\062\003\000\002\062\003\000" +
    "\002\062\003\000\002\063\003\000\002\063\003\000\002" +
    "\064\003\000\002\064\003\000\002\064\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\356\000\004\004\005\001\002\000\004\002\360\001" +
    "\002\000\004\021\007\001\002\000\012\006\ufffd\010\ufffd" +
    "\021\ufffd\055\ufffd\001\002\000\012\006\uffff\010\uffff\021" +
    "\uffff\055\uffff\001\002\000\012\006\021\010\022\021\013" +
    "\055\012\001\002\000\006\003\uffe9\021\uffe9\001\002\000" +
    "\010\016\ufff6\021\ufff6\056\ufff6\001\002\000\054\003\uffe8" +
    "\021\uffe8\026\uffe8\027\uffe8\030\uffe8\031\uffe8\032\uffe8\033" +
    "\uffe8\034\uffe8\035\uffe8\036\uffe8\037\uffe8\040\uffe8\041\uffe8" +
    "\042\uffe8\046\uffe8\047\uffe8\052\uffe8\053\uffe8\054\uffe8\055" +
    "\uffe8\001\002\000\006\003\343\021\345\001\002\000\012" +
    "\006\ufffb\010\ufffb\021\ufffb\055\ufffb\001\002\000\012\006" +
    "\ufffa\010\ufffa\021\ufffa\055\ufffa\001\002\000\012\006\ufffe" +
    "\010\ufffe\021\ufffe\055\ufffe\001\002\000\012\006\ufffc\010" +
    "\ufffc\021\ufffc\055\ufffc\001\002\000\004\021\047\001\002" +
    "\000\006\003\023\021\013\001\002\000\004\046\046\001" +
    "\002\000\006\003\025\021\030\001\002\000\006\046\044" +
    "\047\043\001\002\000\006\046\ufff0\047\ufff0\001\002\000" +
    "\006\046\041\047\040\001\002\000\004\043\031\001\002" +
    "\000\014\003\033\022\034\023\037\024\036\025\032\001" +
    "\002\000\006\046\uffea\047\uffea\001\002\000\006\046\uffee" +
    "\047\uffee\001\002\000\006\046\uffed\047\uffed\001\002\000" +
    "\006\046\uffef\047\uffef\001\002\000\006\046\uffeb\047\uffeb" +
    "\001\002\000\006\046\uffec\047\uffec\001\002\000\004\021" +
    "\030\001\002\000\012\006\ufff5\010\ufff5\021\ufff5\055\ufff5" +
    "\001\002\000\006\046\ufff2\047\ufff2\001\002\000\004\021" +
    "\030\001\002\000\012\006\ufff4\010\ufff4\021\ufff4\055\ufff4" +
    "\001\002\000\006\046\ufff1\047\ufff1\001\002\000\012\006" +
    "\ufff3\010\ufff3\021\ufff3\055\ufff3\001\002\000\006\020\uffd9" +
    "\055\uffd9\001\002\000\006\020\051\055\uffd3\001\002\000" +
    "\006\003\342\021\013\001\002\000\004\055\053\001\002" +
    "\000\010\021\uffd8\055\uffd8\056\uffd8\001\002\000\010\021" +
    "\ufff8\055\ufff8\056\ufff8\001\002\000\010\021\013\055\uffd7" +
    "\056\uffd7\001\002\000\010\021\ufff9\055\ufff9\056\ufff9\001" +
    "\002\000\006\055\075\056\uffd1\001\002\000\006\003\061" +
    "\021\062\001\002\000\012\021\uffdf\046\073\055\uffdf\056" +
    "\uffdf\001\002\000\010\046\uffda\047\uffda\053\071\001\002" +
    "\000\006\046\066\047\065\001\002\000\006\046\uffdd\047" +
    "\uffdd\001\002\000\004\021\062\001\002\000\010\021\uffe1" +
    "\055\uffe1\056\uffe1\001\002\000\006\046\uffde\047\uffde\001" +
    "\002\000\006\046\uffdc\047\uffdc\001\002\000\004\054\072" +
    "\001\002\000\010\046\uffdb\047\uffdb\052\uffdb\001\002\000" +
    "\010\021\uffe0\055\uffe0\056\uffe0\001\002\000\004\056\uffd2" +
    "\001\002\000\010\016\ufff6\021\ufff6\056\ufff6\001\002\000" +
    "\004\056\077\001\002\000\012\006\uffd6\010\uffd6\021\uffd6" +
    "\055\uffd6\001\002\000\010\016\104\021\013\056\102\001" +
    "\002\000\004\021\uffcd\001\002\000\004\056\uffd0\001\002" +
    "\000\010\016\ufff7\021\ufff7\056\ufff7\001\002\000\004\021" +
    "\uffcc\001\002\000\004\021\106\001\002\000\004\051\uffcf" +
    "\001\002\000\004\051\110\001\002\000\010\003\112\021" +
    "\013\052\uffca\001\002\000\006\003\336\021\337\001\002" +
    "\000\004\047\334\001\002\000\004\052\120\001\002\000" +
    "\006\047\116\052\uffcb\001\002\000\006\047\uffc7\052\uffc7" +
    "\001\002\000\004\021\013\001\002\000\006\047\uffc9\052" +
    "\uffc9\001\002\000\006\021\ufff8\055\ufff8\001\002\000\006" +
    "\021\013\055\122\001\002\000\024\005\uffc3\011\uffc3\013" +
    "\uffc3\014\uffc3\015\uffc3\017\uffc3\021\uffc3\055\uffc3\056\uffc3" +
    "\001\002\000\024\005\142\011\136\013\144\014\125\015" +
    "\135\017\133\021\127\055\137\056\131\001\002\000\012" +
    "\043\315\044\316\045\317\051\320\001\002\000\004\051" +
    "\310\001\002\000\026\005\uffb5\007\uffb5\011\uffb5\013\uffb5" +
    "\014\uffb5\015\uffb5\017\uffb5\021\uffb5\055\uffb5\056\uffb5\001" +
    "\002\000\060\026\uffa4\027\uffa4\030\uffa4\031\uffa4\032\uffa4" +
    "\033\uffa4\034\uffa4\035\uffa4\036\uffa4\037\uffa4\040\uffa4\041" +
    "\uffa4\042\uffa4\043\uffa4\044\uffa4\045\uffa4\046\uffa4\047\uffa4" +
    "\050\uffa4\051\uffa4\052\uffa4\053\uffa4\054\uffa4\001\002\000" +
    "\026\005\uffbd\007\uffbd\011\uffbd\013\uffbd\014\uffbd\015\uffbd" +
    "\017\uffbd\021\uffbd\055\uffbd\056\uffbd\001\002\000\010\016" +
    "\uffce\021\uffce\056\uffce\001\002\000\026\005\uffb9\007\uffb9" +
    "\011\uffb9\013\uffb9\014\uffb9\015\uffb9\017\uffb9\021\uffb9\055" +
    "\uffb9\056\uffb9\001\002\000\004\051\303\001\002\000\026" +
    "\005\uffb7\007\uffb7\011\uffb7\013\uffb7\014\uffb7\015\uffb7\017" +
    "\uffb7\021\uffb7\055\uffb7\056\uffb7\001\002\000\024\012\160" +
    "\021\127\022\162\023\167\024\156\025\163\027\155\046" +
    "\uff8f\051\166\001\002\000\004\051\246\001\002\000\024" +
    "\005\uffc3\011\uffc3\013\uffc3\014\uffc3\015\uffc3\017\uffc3\021" +
    "\uffc3\055\uffc3\056\uffc3\001\002\000\026\005\uffb3\007\uffb3" +
    "\011\uffb3\013\uffb3\014\uffb3\015\uffb3\017\uffb3\021\uffb3\055" +
    "\uffb3\056\uffb3\001\002\000\060\026\uffa7\027\uffa7\030\uffa7" +
    "\031\uffa7\032\uffa7\033\uffa7\034\uffa7\035\uffa7\036\uffa7\037" +
    "\uffa7\040\uffa7\041\uffa7\042\uffa7\043\uffa7\044\uffa7\045\uffa7" +
    "\046\uffa7\047\uffa7\050\235\051\uffa7\052\uffa7\053\236\054" +
    "\uffa7\001\002\000\004\046\234\001\002\000\024\005\uffc1" +
    "\011\uffc1\013\uffc1\014\uffc1\015\uffc1\017\uffc1\021\uffc1\055" +
    "\uffc1\056\uffc1\001\002\000\004\051\154\001\002\000\024" +
    "\005\uffc4\011\uffc4\013\uffc4\014\uffc4\015\uffc4\017\uffc4\021" +
    "\uffc4\055\uffc4\056\uffc4\001\002\000\026\005\uffb8\007\uffb8" +
    "\011\uffb8\013\uffb8\014\uffb8\015\uffb8\017\uffb8\021\uffb8\055" +
    "\uffb8\056\uffb8\001\002\000\026\005\uffb4\007\uffb4\011\uffb4" +
    "\013\uffb4\014\uffb4\015\uffb4\017\uffb4\021\uffb4\055\uffb4\056" +
    "\uffb4\001\002\000\024\005\uffbe\011\uffbe\013\uffbe\014\uffbe" +
    "\015\uffbe\017\uffbe\021\uffbe\055\uffbe\056\uffbe\001\002\000" +
    "\026\005\uffbb\007\uffbb\011\uffbb\013\uffbb\014\uffbb\015\uffbb" +
    "\017\uffbb\021\uffbb\055\uffbb\056\uffbb\001\002\000\024\005" +
    "\uffc2\011\uffc2\013\uffc2\014\uffc2\015\uffc2\017\uffc2\021\uffc2" +
    "\055\uffc2\056\uffc2\001\002\000\026\005\uffba\007\uffba\011" +
    "\uffba\013\uffba\014\uffba\015\uffba\017\uffba\021\uffba\055\uffba" +
    "\056\uffba\001\002\000\022\012\160\021\127\022\162\023" +
    "\167\024\156\025\163\027\155\051\166\001\002\000\020" +
    "\012\160\021\127\022\162\023\167\024\156\025\163\051" +
    "\166\001\002\000\044\026\uff82\027\uff82\030\uff82\031\uff82" +
    "\032\uff82\033\uff82\034\uff82\035\uff82\036\uff82\037\uff82\040" +
    "\uff82\041\uff82\042\uff82\046\uff82\047\uff82\052\uff82\054\uff82" +
    "\001\002\000\006\047\225\052\uff8b\001\002\000\004\021" +
    "\013\001\002\000\046\026\uff7c\027\uff7c\030\uff7c\031\uff7c" +
    "\032\uff7c\033\uff7c\034\uff7c\035\uff7c\036\uff7c\037\uff7c\040" +
    "\uff7c\041\uff7c\042\uff7c\046\uff7c\047\uff7c\051\210\052\uff7c" +
    "\054\uff7c\001\002\000\044\026\uff85\027\uff85\030\uff85\031" +
    "\uff85\032\uff85\033\uff85\034\uff85\035\uff85\036\uff85\037\uff85" +
    "\040\uff85\041\uff85\042\uff85\046\uff85\047\uff85\052\uff85\054" +
    "\uff85\001\002\000\044\026\uff83\027\uff83\030\uff83\031\uff83" +
    "\032\uff83\033\uff83\034\uff83\035\uff83\036\uff83\037\uff83\040" +
    "\uff83\041\uff83\042\uff83\046\uff83\047\uff83\052\uff83\054\uff83" +
    "\001\002\000\036\026\uff9f\027\uff9f\033\uff9f\034\uff9f\035" +
    "\uff9f\036\uff9f\037\uff9f\040\uff9f\041\uff9f\042\uff9f\046\uff9f" +
    "\047\uff9f\052\uff9f\054\uff9f\001\002\000\044\026\uff88\027" +
    "\uff88\030\uff88\031\uff88\032\uff88\033\uff88\034\uff88\035\uff88" +
    "\036\uff88\037\uff88\040\uff88\041\uff88\042\uff88\046\uff88\047" +
    "\uff88\052\uff88\054\uff88\001\002\000\022\012\160\021\127" +
    "\022\162\023\167\024\156\025\163\027\155\051\166\001" +
    "\002\000\044\026\uff84\027\uff84\030\uff84\031\uff84\032\uff84" +
    "\033\uff84\034\uff84\035\uff84\036\uff84\037\uff84\040\uff84\041" +
    "\uff84\042\uff84\046\uff84\047\uff84\052\uff84\054\uff84\001\002" +
    "\000\004\052\171\001\002\000\044\026\uff7f\027\uff7f\030" +
    "\uff7f\031\uff7f\032\uff7f\033\uff7f\034\uff7f\035\uff7f\036\uff7f" +
    "\037\uff7f\040\uff7f\041\uff7f\042\uff7f\046\uff7f\047\uff7f\052" +
    "\uff7f\054\uff7f\001\002\000\044\026\uff8a\027\uff8a\030\174" +
    "\031\176\032\173\033\uff8a\034\uff8a\035\uff8a\036\uff8a\037" +
    "\uff8a\040\uff8a\041\uff8a\042\uff8a\046\uff8a\047\uff8a\052\uff8a" +
    "\054\uff8a\001\002\000\020\012\uff71\021\uff71\022\uff71\023" +
    "\uff71\024\uff71\025\uff71\051\uff71\001\002\000\020\012\uff73" +
    "\021\uff73\022\uff73\023\uff73\024\uff73\025\uff73\051\uff73\001" +
    "\002\000\044\026\uff89\027\uff89\030\uff89\031\uff89\032\uff89" +
    "\033\uff89\034\uff89\035\uff89\036\uff89\037\uff89\040\uff89\041" +
    "\uff89\042\uff89\046\uff89\047\uff89\052\uff89\054\uff89\001\002" +
    "\000\020\012\uff72\021\uff72\022\uff72\023\uff72\024\uff72\025" +
    "\uff72\051\uff72\001\002\000\020\012\160\021\127\022\162" +
    "\023\167\024\156\025\163\051\166\001\002\000\044\026" +
    "\uff87\027\uff87\030\uff87\031\uff87\032\uff87\033\uff87\034\uff87" +
    "\035\uff87\036\uff87\037\uff87\040\uff87\041\uff87\042\uff87\046" +
    "\uff87\047\uff87\052\uff87\054\uff87\001\002\000\036\026\202" +
    "\027\203\033\uffa2\034\uffa2\035\uffa2\036\uffa2\037\uffa2\040" +
    "\uffa2\041\uffa2\042\uffa2\046\uffa2\047\uffa2\052\uffa2\054\uffa2" +
    "\001\002\000\020\012\uff75\021\uff75\022\uff75\023\uff75\024" +
    "\uff75\025\uff75\051\uff75\001\002\000\020\012\uff74\021\uff74" +
    "\022\uff74\023\uff74\024\uff74\025\uff74\051\uff74\001\002\000" +
    "\036\026\uffa0\027\uffa0\033\uffa0\034\uffa0\035\uffa0\036\uffa0" +
    "\037\uffa0\040\uffa0\041\uffa0\042\uffa0\046\uffa0\047\uffa0\052" +
    "\uffa0\054\uffa0\001\002\000\020\012\160\021\127\022\162" +
    "\023\167\024\156\025\163\051\166\001\002\000\036\026" +
    "\uff9e\027\uff9e\033\uff9e\034\uff9e\035\uff9e\036\uff9e\037\uff9e" +
    "\040\uff9e\041\uff9e\042\uff9e\046\uff9e\047\uff9e\052\uff9e\054" +
    "\uff9e\001\002\000\044\026\uff86\027\uff86\030\uff86\031\uff86" +
    "\032\uff86\033\uff86\034\uff86\035\uff86\036\uff86\037\uff86\040" +
    "\uff86\041\uff86\042\uff86\046\uff86\047\uff86\052\uff86\054\uff86" +
    "\001\002\000\026\003\214\012\160\021\127\022\162\023" +
    "\167\024\156\025\163\027\155\051\166\052\uffaa\001\002" +
    "\000\006\047\uffa8\052\uffa8\001\002\000\004\052\220\001" +
    "\002\000\006\047\216\052\uffab\001\002\000\004\052\215" +
    "\001\002\000\044\026\uff7d\027\uff7d\030\uff7d\031\uff7d\032" +
    "\uff7d\033\uff7d\034\uff7d\035\uff7d\036\uff7d\037\uff7d\040\uff7d" +
    "\041\uff7d\042\uff7d\046\uff7d\047\uff7d\052\uff7d\054\uff7d\001" +
    "\002\000\022\012\160\021\127\022\162\023\167\024\156" +
    "\025\163\027\155\051\166\001\002\000\006\047\uffa9\052" +
    "\uffa9\001\002\000\044\026\uff7e\027\uff7e\030\uff7e\031\uff7e" +
    "\032\uff7e\033\uff7e\034\uff7e\035\uff7e\036\uff7e\037\uff7e\040" +
    "\uff7e\041\uff7e\042\uff7e\046\uff7e\047\uff7e\052\uff7e\054\uff7e" +
    "\001\002\000\046\026\uff80\027\uff80\030\uff80\031\uff80\032" +
    "\uff80\033\uff80\034\uff80\035\uff80\036\uff80\037\uff80\040\uff80" +
    "\041\uff80\042\uff80\046\uff80\047\uff80\052\uff80\053\222\054" +
    "\uff80\001\002\000\022\012\160\021\127\022\162\023\167" +
    "\024\156\025\163\027\155\051\166\001\002\000\004\054" +
    "\224\001\002\000\044\026\uff81\027\uff81\030\uff81\031\uff81" +
    "\032\uff81\033\uff81\034\uff81\035\uff81\036\uff81\037\uff81\040" +
    "\uff81\041\uff81\042\uff81\046\uff81\047\uff81\052\uff81\054\uff81" +
    "\001\002\000\004\022\231\001\002\000\004\052\227\001" +
    "\002\000\004\046\230\001\002\000\026\005\uff8d\007\uff8d" +
    "\011\uff8d\013\uff8d\014\uff8d\015\uff8d\017\uff8d\021\uff8d\055" +
    "\uff8d\056\uff8d\001\002\000\004\052\uff8c\001\002\000\036" +
    "\026\uff9f\027\uff9f\033\uff9f\034\uff9f\035\uff9f\036\uff9f\037" +
    "\uff9f\040\uff9f\041\uff9f\042\uff9f\046\uff9f\047\uff9f\052\uff9f" +
    "\054\uff9f\001\002\000\036\026\202\027\203\033\uffa1\034" +
    "\uffa1\035\uffa1\036\uffa1\037\uffa1\040\uffa1\041\uffa1\042\uffa1" +
    "\046\uffa1\047\uffa1\052\uffa1\054\uffa1\001\002\000\026\005" +
    "\uff92\007\uff92\011\uff92\013\uff92\014\uff92\015\uff92\017\uff92" +
    "\021\uff92\055\uff92\056\uff92\001\002\000\004\021\243\001" +
    "\002\000\024\003\240\012\160\021\127\022\162\023\167" +
    "\024\156\025\163\027\155\051\166\001\002\000\004\054" +
    "\242\001\002\000\004\054\241\001\002\000\060\026\uffa3" +
    "\027\uffa3\030\uffa3\031\uffa3\032\uffa3\033\uffa3\034\uffa3\035" +
    "\uffa3\036\uffa3\037\uffa3\040\uffa3\041\uffa3\042\uffa3\043\uffa3" +
    "\044\uffa3\045\uffa3\046\uffa3\047\uffa3\050\uffa3\051\uffa3\052" +
    "\uffa3\053\uffa3\054\uffa3\001\002\000\060\026\uffa5\027\uffa5" +
    "\030\uffa5\031\uffa5\032\uffa5\033\uffa5\034\uffa5\035\uffa5\036" +
    "\uffa5\037\uffa5\040\uffa5\041\uffa5\042\uffa5\043\uffa5\044\uffa5" +
    "\045\uffa5\046\uffa5\047\uffa5\050\uffa5\051\uffa5\052\uffa5\053" +
    "\uffa5\054\uffa5\001\002\000\060\026\uffa6\027\uffa6\030\uffa6" +
    "\031\uffa6\032\uffa6\033\uffa6\034\uffa6\035\uffa6\036\uffa6\037" +
    "\uffa6\040\uffa6\041\uffa6\042\uffa6\043\uffa6\044\uffa6\045\uffa6" +
    "\046\uffa6\047\uffa6\050\uffa6\051\uffa6\052\uffa6\053\uffa6\054" +
    "\uffa6\001\002\000\024\005\142\011\136\013\144\014\125" +
    "\015\135\017\133\021\127\055\137\056\245\001\002\000" +
    "\026\005\uffb6\007\uffb6\011\uffb6\013\uffb6\014\uffb6\015\uffb6" +
    "\017\uffb6\021\uffb6\055\uffb6\056\uffb6\001\002\000\024\003" +
    "\252\012\160\021\127\022\162\023\167\024\156\025\163" +
    "\027\155\051\166\001\002\000\024\033\270\034\266\035" +
    "\275\036\274\037\273\040\276\041\uff96\042\uff96\052\uff96" +
    "\001\002\000\006\042\257\052\256\001\002\000\010\041" +
    "\uff99\042\uff99\052\uff99\001\002\000\006\042\uff9b\052\uff9b" +
    "\001\002\000\010\041\254\042\uff9c\052\uff9c\001\002\000" +
    "\022\012\160\021\127\022\162\023\167\024\156\025\163" +
    "\027\155\051\166\001\002\000\010\041\uff9a\042\uff9a\052" +
    "\uff9a\001\002\000\022\005\142\011\136\013\144\014\125" +
    "\015\135\017\133\021\127\055\137\001\002\000\022\012" +
    "\160\021\127\022\162\023\167\024\156\025\163\027\155" +
    "\051\166\001\002\000\010\041\254\042\uff9d\052\uff9d\001" +
    "\002\000\024\005\uffc0\011\uffc0\013\uffc0\014\uffc0\015\uffc0" +
    "\017\uffc0\021\uffc0\055\uffc0\056\uffc0\001\002\000\026\005" +
    "\uffc2\007\263\011\uffc2\013\uffc2\014\uffc2\015\uffc2\017\uffc2" +
    "\021\uffc2\055\uffc2\056\uffc2\001\002\000\022\005\142\011" +
    "\136\013\144\014\125\015\135\017\133\021\127\055\137" +
    "\001\002\000\024\005\uffbf\011\uffbf\013\uffbf\014\uffbf\015" +
    "\uffbf\017\uffbf\021\uffbf\055\uffbf\056\uffbf\001\002\000\026" +
    "\005\uffbc\007\uffbc\011\uffbc\013\uffbc\014\uffbc\015\uffbc\017" +
    "\uffbc\021\uffbc\055\uffbc\056\uffbc\001\002\000\022\012\uff7a" +
    "\021\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\027\uff7a\051" +
    "\uff7a\001\002\000\010\041\uff98\042\uff98\052\uff98\001\002" +
    "\000\022\012\uff7b\021\uff7b\022\uff7b\023\uff7b\024\uff7b\025" +
    "\uff7b\027\uff7b\051\uff7b\001\002\000\010\041\uff97\042\uff97" +
    "\052\uff97\001\002\000\022\012\160\021\127\022\162\023" +
    "\167\024\156\025\163\027\155\051\166\001\002\000\022" +
    "\012\uff77\021\uff77\022\uff77\023\uff77\024\uff77\025\uff77\027" +
    "\uff77\051\uff77\001\002\000\022\012\uff78\021\uff78\022\uff78" +
    "\023\uff78\024\uff78\025\uff78\027\uff78\051\uff78\001\002\000" +
    "\022\012\uff79\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79" +
    "\027\uff79\051\uff79\001\002\000\022\012\uff76\021\uff76\022" +
    "\uff76\023\uff76\024\uff76\025\uff76\027\uff76\051\uff76\001\002" +
    "\000\010\041\uff95\042\uff95\052\uff95\001\002\000\004\046" +
    "\302\001\002\000\004\046\uff90\001\002\000\026\005\uff91" +
    "\007\uff91\011\uff91\013\uff91\014\uff91\015\uff91\017\uff91\021" +
    "\uff91\055\uff91\056\uff91\001\002\000\024\003\252\012\160" +
    "\021\127\022\162\023\167\024\156\025\163\027\155\051" +
    "\166\001\002\000\006\042\257\052\305\001\002\000\022" +
    "\005\142\011\136\013\144\014\125\015\135\017\133\021" +
    "\127\055\137\001\002\000\024\005\uff93\011\uff93\013\uff93" +
    "\014\uff93\015\uff93\017\uff93\021\uff93\055\uff93\056\uff93\001" +
    "\002\000\026\005\uff94\007\uff94\011\uff94\013\uff94\014\uff94" +
    "\015\uff94\017\uff94\021\uff94\055\uff94\056\uff94\001\002\000" +
    "\004\021\127\001\002\000\004\052\312\001\002\000\004" +
    "\046\313\001\002\000\026\005\uff8e\007\uff8e\011\uff8e\013" +
    "\uff8e\014\uff8e\015\uff8e\017\uff8e\021\uff8e\055\uff8e\056\uff8e" +
    "\001\002\000\004\046\333\001\002\000\024\003\330\012" +
    "\160\021\127\022\162\023\167\024\156\025\163\027\155" +
    "\051\166\001\002\000\004\046\uffaf\001\002\000\004\046" +
    "\uffae\001\002\000\026\003\322\012\160\021\127\022\162" +
    "\023\167\024\156\025\163\027\155\051\166\052\uffaa\001" +
    "\002\000\004\052\325\001\002\000\004\052\323\001\002" +
    "\000\004\046\324\001\002\000\026\005\uffac\007\uffac\011" +
    "\uffac\013\uffac\014\uffac\015\uffac\017\uffac\021\uffac\055\uffac" +
    "\056\uffac\001\002\000\004\046\326\001\002\000\026\005" +
    "\uffad\007\uffad\011\uffad\013\uffad\014\uffad\015\uffad\017\uffad" +
    "\021\uffad\055\uffad\056\uffad\001\002\000\004\046\332\001" +
    "\002\000\004\046\331\001\002\000\026\005\uffb1\007\uffb1" +
    "\011\uffb1\013\uffb1\014\uffb1\015\uffb1\017\uffb1\021\uffb1\055" +
    "\uffb1\056\uffb1\001\002\000\026\005\uffb2\007\uffb2\011\uffb2" +
    "\013\uffb2\014\uffb2\015\uffb2\017\uffb2\021\uffb2\055\uffb2\056" +
    "\uffb2\001\002\000\026\005\uffb0\007\uffb0\011\uffb0\013\uffb0" +
    "\014\uffb0\015\uffb0\017\uffb0\021\uffb0\055\uffb0\056\uffb0\001" +
    "\002\000\004\021\013\001\002\000\006\047\uffc8\052\uffc8" +
    "\001\002\000\006\047\uffc5\052\uffc5\001\002\000\010\047" +
    "\uffda\052\uffda\053\071\001\002\000\006\047\uffc6\052\uffc6" +
    "\001\002\000\004\055\uffd5\001\002\000\004\055\uffd4\001" +
    "\002\000\006\046\354\047\353\001\002\000\006\046\uffe3" +
    "\047\uffe3\001\002\000\010\046\uffda\047\uffda\053\071\001" +
    "\002\000\006\046\350\047\347\001\002\000\004\021\345" +
    "\001\002\000\012\006\uffe7\010\uffe7\021\uffe7\055\uffe7\001" +
    "\002\000\006\046\uffe5\047\uffe5\001\002\000\006\046\uffe2" +
    "\047\uffe2\001\002\000\004\021\345\001\002\000\012\006" +
    "\uffe6\010\uffe6\021\uffe6\055\uffe6\001\002\000\006\046\uffe4" +
    "\047\uffe4\001\002\000\010\016\104\021\013\056\357\001" +
    "\002\000\004\002\001\001\002\000\004\002\000\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\356\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\071\005\001\001\000\004\003\007\001\001\000\002" +
    "\001\001\000\016\004\016\005\017\010\013\011\014\014" +
    "\015\075\010\001\001\000\002\001\001\000\004\020\355" +
    "\001\001\000\002\001\001\000\006\012\345\013\343\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\010\023\075" +
    "\010\001\001\000\002\001\001\000\006\006\026\007\025" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\074\034\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\007\041" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\007" +
    "\044\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\104\047\001\001\000\004\015\051\001" +
    "\001\000\004\075\340\001\001\000\002\001\001\000\004" +
    "\105\053\001\001\000\004\065\054\001\001\000\012\010" +
    "\057\066\055\075\010\106\056\001\001\000\002\001\001" +
    "\000\006\016\075\017\073\001\001\000\006\067\062\070" +
    "\063\001\001\000\002\001\001\000\004\077\067\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\070\066\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\020\077\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\021\102\075\100\076\104\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\107\106\001" +
    "\001\000\002\001\001\000\012\022\112\023\113\024\114" +
    "\075\110\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\024\116\075\110\001\001\000\002\001\001\000\004\065" +
    "\120\001\001\000\010\010\057\066\055\075\010\001\001" +
    "\000\004\025\122\001\001\000\040\026\144\027\151\030" +
    "\142\031\127\032\150\033\147\034\152\035\131\036\145" +
    "\037\133\072\123\073\140\100\125\101\146\103\137\001" +
    "\001\000\004\102\313\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\042\300\053\277\055\163\060\164\072\160\073" +
    "\140\001\001\000\002\001\001\000\004\025\243\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\042\156" +
    "\055\163\060\164\072\160\073\140\001\001\000\012\055" +
    "\231\060\164\072\160\073\140\001\001\000\002\001\001" +
    "\000\004\054\225\001\001\000\004\075\220\001\001\000" +
    "\004\061\206\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\044\200\001\001\000\004\056\171\001\001\000" +
    "\014\042\167\055\163\060\164\072\160\073\140\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\057\174\064\176\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\060" +
    "\177\072\160\073\140\001\001\000\002\001\001\000\006" +
    "\045\203\063\204\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\055\205\060\164\072\160" +
    "\073\140\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\040\211\041\212\042\210\055\163\060\164\072\160" +
    "\073\140\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\042\216\055\163\060\164\072\160\073\140\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\042\222\055\163\060\164\072\160\073\140\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\044\232\001\001\000\006\045\203\063\204" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\042" +
    "\236\055\163\060\164\072\160\073\140\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\040\026\144\027\151\030\142" +
    "\031\127\032\150\033\147\034\152\035\131\036\145\037" +
    "\133\072\123\073\140\100\125\101\146\103\137\001\001" +
    "\000\002\001\001\000\022\042\246\046\247\047\252\050" +
    "\250\055\163\060\164\072\160\073\140\001\001\000\010" +
    "\051\266\052\270\062\271\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\042\246\050\254\055\163\060\164\072\160\073\140\001" +
    "\001\000\002\001\001\000\040\026\260\027\261\030\142" +
    "\031\127\032\150\033\147\034\152\035\131\036\145\037" +
    "\133\072\123\073\140\100\125\101\146\103\137\001\001" +
    "\000\020\042\246\047\257\050\250\055\163\060\164\072" +
    "\160\073\140\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\036\027\264\030\263\031\127\032" +
    "\150\033\147\034\152\035\131\036\145\037\133\072\123" +
    "\073\140\100\125\101\146\103\137\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\042\276\055" +
    "\163\060\164\072\160\073\140\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\022\042\246\046\303\047\252\050\250\055" +
    "\163\060\164\072\160\073\140\001\001\000\002\001\001" +
    "\000\036\027\306\030\305\031\127\032\150\033\147\034" +
    "\152\035\131\036\145\037\133\072\123\073\140\100\125" +
    "\101\146\103\137\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\072\310\073\140\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\042\326\055\163\060\164\072\160\073\140\001\001" +
    "\000\002\001\001\000\002\001\001\000\020\040\320\041" +
    "\212\042\210\055\163\060\164\072\160\073\140\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\024\334\075\110\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\077\337\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\077\351\001" +
    "\001\000\002\001\001\000\004\013\350\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\013" +
    "\354\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\021\102\075\100\076\104\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	Tab.init(); // Universe scope
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "string", stringType));
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "bool", boolType));

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null) 
		//log.info(s.toString() + " " + s.value.toString());
	return s;

    }



	public static final Struct stringType = new Struct(Struct.Array, new Struct(Struct.Char, Tab.noType));
	public static final Struct boolType = new Struct(Struct.Int);

	Logger log = Logger.getLogger(getClass());
	
	Struct type;
	public boolean semError = false;
	
	boolean inClass = false,
			inMain = false,
			method = false,
			attrDef = false;
	
	// nivo A
	int globalVarCnt = 0,			//	definicije glob prom
		localVarCnt = 0,			//	definicije lokalnih prom u mainu
		globalConstCnt = 0,			//	definicije glob konstanti
		globalArrayCnt = 0;			// 	deklaracije glob nizova
		
	// nivo B
	int functionCnt = 0,			// definicije funkcija u glavnom programu
		blockCnt = 0,				//	blokovi naredbi
		callCnt = 0,				//	pozivi funkcija u main metodi
		formParCnt = 0;				//	deklaracije form argumenata funkcija
		
	// nivo C
	int nestedClassCnt = 0,			//	definicije unutr klasa
		nestedClassMethodCnt = 0,	//	definicije metoda unutr klasa
		nestedClassAttrCnt = 0;		//	deklaracije polja unutr klasa 
   
    
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal syntax error - ", cur_token);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void report_error(String message, Object info) {
    	semError = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol) {
            msg.append (" at row ").append(((Symbol)info).left);
            msg.append (" - unrecognized symbol '").append(((Symbol)info).value + "'");
        }
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at row ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
    public void report_debug(String message) {
    	StringBuilder msg = new StringBuilder(message); 
        log.debug(msg.toString());
    }
    
    public String objToString(Obj o) {
    	SymbolTableVisitor stv = new DumpSymbolTableVisitor();
    	
    	stv.visitObjNode(o);
    	return stv.getOutput();
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	Obj currentMethod = null;
	Obj currentClass = null;
	Obj currentDesignator = null;
	boolean returnFound = false;
	int fpPos = 0;
	boolean isVoid = false;

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Mulop ::= MOD 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Mulop ::= DIV 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Mulop ::= MUL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Addop ::= MINUS 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Addop ::= PLUS 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Relop ::= LEQ 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Relop ::= LESS 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Relop ::= GREQ 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Relop ::= GRE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // Relop ::= NEQ 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Relop ::= EQ 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // ParenActParsOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ParenActParsOpt",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // ParenActParsOpt ::= LPAREN error RPAREN 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - actual parameters list"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ParenActParsOpt",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // ParenActParsOpt ::= LPAREN ActParsOpt RPAREN 
            {
              Object RESULT =null;
		 
					if (parser.inMain) 
						parser.callCnt++; 
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ParenActParsOpt",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Factor ::= LPAREN Expr RPAREN 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Factor ::= NEW Type 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Factor ::= NEW Type LBRACKET Expr RBRACKET 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Factor ::= BOOL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Factor ::= STRING 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // Factor ::= CHAR 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Factor ::= NUMBER 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // Factor ::= Designator ParenActParsOpt 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // MulopFactor ::= Mulop Factor 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopFactor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // MulopFactorList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopFactorList",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // MulopFactorList ::= MulopFactorList MulopFactor 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopFactorList",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // Term ::= Factor MulopFactorList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // NumberOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumberOpt",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // NumberOpt ::= COMMA NUMBER 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumberOpt",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // PrintStatement ::= PRINT LPAREN Expr NumberOpt RPAREN SEMI_COMMA 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("PrintStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // ReadStatement ::= READ LPAREN Designator RPAREN SEMI_COMMA 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReadStatement",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // ExprOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprOpt",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // ExprOpt ::= Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprOpt",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // ReturnStatement ::= RETURN ExprOpt SEMI_COMMA 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					returnFound = true;
				 	/*
				 	Struct currMethType = currentMethod.getType();
				 	if (!currMethType.compatibleWith(expr)) {
				 		parser.report_error("Greska na liniji " + tleft + " : " + "tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije " + currentMethod.getName(), null);
				 	}
				 	*/		  	 
			    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnStatement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // BreakStatement ::= BREAK SEMI_COMMA 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BreakStatement",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // UnmatchedWhileStatement ::= WHILE LPAREN Condition RPAREN Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("UnmatchedWhileStatement",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // MatchedWhileStatement ::= WHILE LPAREN Condition RPAREN Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MatchedWhileStatement",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // RelopExpr ::= Relop Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelopExpr",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // RelopExprOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelopExprOpt",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // RelopExprOpt ::= RelopExpr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelopExprOpt",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // CondFact ::= Expr RelopExprOpt 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // CondTerm ::= CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // CondTerm ::= CondTerm AND CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // Condition ::= error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - condition of an if/while construction"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // Condition ::= CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // Condition ::= Condition OR CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // AddopTerm ::= Addop Term 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTerm",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // AddopTermList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermList",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // AddopTermList ::= AddopTermList AddopTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermList",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // Expr ::= MINUS Term AddopTermList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // Expr ::= Term AddopTermList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // DesignatorList ::= DesignatorList LBRACKET error RBRACKET 
            {
              Obj RESULT =null;
		 parser.report_debug("Successful error recovery - array indexing"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // DesignatorList ::= IDENT 
            {
              Obj RESULT =null;
		int identleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int identright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String ident = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					Obj o = Tab.find(ident);
					if (o != Tab.noObj) {
						parser.report_info("Use of " + parser.objToString(o) + " at row " + identleft,null);		
					} else {
                    	parser.report_error("Semantics error at row " + identleft + " - symbol '" + ident + "' not found",null);					
					}
					RESULT = o;
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // DesignatorList ::= DesignatorList LBRACKET Expr RBRACKET 
            {
              Obj RESULT =null;
		int arrayleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int arrayright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj array = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
					if (array.getType().getKind() != Struct.Array) 
                    	parser.report_error("Semantics error at row " + arrayleft + " - expected an array",null);
                    
                    // Expr mora biti tipa int
                    RESULT = new Obj (Obj.Elem, array.getName(), array.getType().getElemType());
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // DesignatorList ::= DesignatorList STOP IDENT 
            {
              Obj RESULT =null;
		int clleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int clright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj cl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int fieldleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int fieldright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String field = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					if (cl.getType().getKind() != Struct.Class) 
                    	parser.report_error("Semantics error at row " + clleft + " - expected a class",null);
                    
                    // proveri postojanje polja
                    Obj o = cl.getType().getMembers().searchKey(field);
                    if (o == null) {
                    	o = Tab.noObj;
                    	parser.report_error("Semantics error at row " + clleft + " - class attribute '" + field + "' doesn't exist",null);
                    } else {
                    	parser.report_info("Use of " + parser.objToString(o) + " at row " + clleft,null);
                    }
                    RESULT = o;
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // Designator ::= DesignatorList 
            {
              Obj RESULT =null;
		int dlistleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dlistright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj dlist = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = dlist; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // ActPars ::= Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // ActPars ::= ActPars COMMA Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // ActParsOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsOpt",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // ActParsOpt ::= ActPars 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsOpt",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // FunctionCall ::= Designator LPAREN error RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - actual parameters list"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FunctionCall",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // FunctionCall ::= Designator LPAREN ActParsOpt RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		 
				if (parser.inMain) 
					parser.callCnt++; 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FunctionCall",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // IncDec ::= DEC 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IncDec",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // IncDec ::= INC 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("IncDec",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // SideEffect ::= Designator IncDec SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if (desig != null)
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_info("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
					} else {
						if (!desig.getType().equals(Tab.intType))
							parser.report_info("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
					}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("SideEffect",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // Assignment ::= Designator EQUALS error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - value assignment"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // Assignment ::= Designator EQUALS Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
					
				if (desig != null)
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_info("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
					}
				// proveri kompatibilnost		
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // ExprStatement ::= FunctionCall 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // ExprStatement ::= SideEffect 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // ExprStatement ::= Assignment 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprStatement",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Matched ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
		 parser.blockCnt++; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Matched ::= PrintStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Matched ::= ReadStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Matched ::= ReturnStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Matched ::= BreakStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Matched ::= MatchedWhileStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Matched ::= IF LPAREN Condition RPAREN Matched ELSE Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Matched ::= ExprStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Unmatched ::= UnmatchedWhileStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Unmatched ::= IF LPAREN Condition RPAREN Matched ELSE Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Unmatched ::= IF LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // Statement ::= Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // Statement ::= Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FormPar ::= Type error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - formal parameter declaration"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // FormPar ::= Type IDENT BracketsOpt 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int parNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int parNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String parName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 					
				parser.formParCnt++;
				
				Obj o = Tab.currentScope().findSymbol(parName);
	 			if (o == null) {
	 				if (!brack.booleanValue())
	 					o = Tab.insert(Obj.Var, parName, type);
	 				else
	 					o = Tab.insert(Obj.Var, parName, new Struct(Struct.Array, type));
	 				o.setFpPos(fpPos);
	 				fpPos++;
	 				parser.report_info("Formal parameter '" + parName + "' declaration at row " + parNameleft, null);
	 			} else {
	 				parser.report_error("Semantics error at row " + parNameleft + " - multiple definition of '" + parName + "'", null);
	 			} 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // FormPars ::= FormPar 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FormPars ::= error COMMA FormPar 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - formal parameter declaration"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // FormPars ::= FormPars COMMA FormPar 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // FormParsOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsOpt",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // FormParsOpt ::= FormPars 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsOpt",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // ReturnType ::= VOID 
            {
              Struct RESULT =null;
		 isVoid = true; RESULT = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // ReturnType ::= Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 isVoid = (type == Tab.noType); RESULT = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // MethodDecl ::= ReturnType IDENT NT$3 LPAREN FormParsOpt RPAREN LocalVarDeclList LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		 
			   	  if (parser.inMain && fpPos > 0)
					parser.report_error("Semantics error at row " + methNameleft + " - 'main' function cannot have parameters", null);
					
			   	  // da li brojimo i main u funkcije
			   	  parser.method = false;
			   	  parser.blockCnt++;
			   	  if (!parser.inClass) 
			   	  	parser.functionCnt++;
			   	  else 
			   	  	parser.nestedClassMethodCnt++;
			   	  if (parser.inMain) 
			   	  	parser.inMain = false;
			   	  	
			   	  if (!returnFound && !isVoid)
			   	 	parser.report_error("Semantics error at row " + methNameleft + " - function '" + methName + "' missing 'return' statement", null);
			   	  
			   	  currentMethod.setLevel(fpPos);
			   	  Tab.chainLocalSymbols(currentMethod);
			   	  Tab.closeScope();
			   	  
			   	  returnFound = isVoid = false;
				  currentMethod = null;
				  fpPos = 0;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // NT$3 ::= 
            {
              Object RESULT =null;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
			   	  parser.method = true; 
			   	  if (!parser.inClass && methName.equals("main")) 
			   	  	parser.inMain = true;
			   	  
			   	  Obj o = Tab.currentScope().findSymbol(methName);
				  if (o == null) {
		 				currentMethod = Tab.insert(Obj.Meth, methName, retType);
		 				parser.report_info("Function '" + methName + "' definition at row " + methNameleft, null);
		 		  } else {
		 		  		currentMethod = o;
		 				parser.report_error("Semantics error at row " + methNameleft + " - multiple definition of a function '" + methName + "'", null);
		 		  }	 
			   	  Tab.openScope();
			   	  
			   	  if (parser.inMain && !isVoid)
			   	  	parser.report_error("Semantics error at row " + methNameleft + " - function '" + methName + "' must be VOID", null);  	   
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",69, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // Methods ::= LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Methods",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // MethodsOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodsOpt",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // MethodsOpt ::= Methods 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodsOpt",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // Extends ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // Extends ::= EXTENDS error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - class inheritance"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // Extends ::= EXTENDS Type 
            {
              Object RESULT =null;
		int outerClassleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int outerClassright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct outerClass = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				if (!(outerClass.getKind() == Struct.Class))
					parser.report_error("Semantics error at row " + outerClassleft + " - outer class must be of a class type", null);
				else if (outerClass == currentClass.getType())
					parser.report_error("Semantics error at row " + outerClassleft + " - class cannot inherit itself", null);
				else
					parser.report_info("Class inheritance at row " + outerClassleft, null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Extends",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // ClassDecl ::= CLASS IDENT NT$0 Extends LBRACE NT$1 LocalVarDeclList NT$2 MethodsOpt RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		 
			  	parser.inClass = false; 
			  	parser.nestedClassCnt++;
			  	Tab.chainLocalSymbols(currentClass.getType());
			   	Tab.closeScope();
			   	currentClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
 parser.attrDef = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$1 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
 parser.attrDef = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // NT$0 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
			  	parser.inClass = true;
			  	
			  	Obj o = Tab.find(className);
			  	if (o == Tab.noObj) {
	 				currentClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
	 				parser.report_info("Class '" + className + "' definition at row " + classNameleft, null);
	 			} else {
	 				currentClass = o;
	 				parser.report_error("Semantics error at row " + classNameleft + " - multiple definition of a class '" + className + "'", null);
	 			}		  		
	 			Tab.openScope();	 			
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // BracketsOpt ::= 
            {
              Boolean RESULT =null;
		 
			 	RESULT = new Boolean(false);
			   	if (!parser.method && !parser.inClass) 
			   		parser.globalVarCnt++; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BracketsOpt",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // BracketsOpt ::= LBRACKET RBRACKET 
            {
              Boolean RESULT =null;
		 
			 	RESULT = new Boolean(true);
			 	if (!parser.method && !parser.inClass) 
			 		parser.globalArrayCnt++; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BracketsOpt",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // LocalVariable ::= IDENT BracketsOpt 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 	
				// brojimo samo lokalne u main funkciji
				if (parser.inMain)
					parser.localVarCnt++;
				else if (parser.inClass && parser.attrDef) 
					parser.nestedClassAttrCnt++;
	 			
	 			Obj o = Tab.currentScope().findSymbol(varName);
	 			if (o == null) {
	 				if (parser.attrDef) {
	 					if (!brack.booleanValue())
		 					Tab.insert(Obj.Fld, varName, parser.type);
	 					else
	 						Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, parser.type));
	 					parser.report_info("Class attribute '" + varName + "' declaration at row " + varNameleft, null);
	 				} else {
	 					if (!brack.booleanValue())
		 					Tab.insert(Obj.Var, varName, parser.type);
	 					else
	 						Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
	 					parser.report_info("Local variable '" + varName + "' declaration at row " + varNameleft, null);
	 				}	
	 			} else {
	 				parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of '" + varName + "'", null);
	 			}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVariable",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // LocalVarList ::= LocalVariable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // LocalVarList ::= LocalVarList COMMA LocalVariable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // LocalVarDecl ::= VarType error 
            {
              Object RESULT =null;
		 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration");
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // LocalVarDecl ::= VarType error SEMI_COMMA 
            {
              Object RESULT =null;
		 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration"); 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // LocalVarDecl ::= VarType LocalVarList SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // Variable ::= IDENT BracketsOpt 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean brack = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 	
	 			Obj o = Tab.find(varName);
	 			if (o == Tab.noObj) {
	 				if (!brack.booleanValue())
		 				Tab.insert(Obj.Var, varName, parser.type);
	 				else
	 					Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
	 				parser.report_info("Global variable '" + varName + "' declaration at row " + varNameleft, null);	
	 			} else {
	 				parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of '" + varName + "'", null);
	 			}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Variable",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // VarList ::= Variable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VarList ::= error COMMA Variable 
            {
              Object RESULT =null;
		 
			parser.report_debug("Successful error recovery - global variable definition");
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VarList ::= VarList COMMA Variable 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VarDecl ::= VarType error SEMI_COMMA 
            {
              Object RESULT =null;
		 
			parser.report_debug("Successful error recovery - global variable definition");
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // VarDecl ::= VarType VarList SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
	Obj typeNode = Tab.find(typeName);
	if (typeNode == Tab.noObj) {
		parser.report_error("Semantics error at row " + typeNameleft + " - type '" + typeName + "' not found in symbol table", null);
		RESULT = Tab.noType;
	}
	else {
		if (Obj.Type == typeNode.getKind()) {
			RESULT = typeNode.getType();
		}
		else {
			parser.report_error("Semantics error at row " + typeNameleft + " - name '" + typeName + "' doesn't represent a type", null);
			RESULT = Tab.noType;
		}
	}

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // VarType ::= Type 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.type = type; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarType",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ConstType ::= STRING 
            {
              Struct RESULT =null;
		 RESULT = parser.stringType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // ConstType ::= BOOL 
            {
              Struct RESULT =null;
		 RESULT = parser.boolType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // ConstType ::= CHAR 
            {
              Struct RESULT =null;
		 RESULT = Tab.charType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // ConstType ::= NUMBER 
            {
              Struct RESULT =null;
		 RESULT = Tab.intType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstType",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // Constant ::= IDENT EQUALS error 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - value assignment (constant)"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Constant",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // Constant ::= IDENT EQUALS ConstType 
            {
              Object RESULT =null;
		int constNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int constNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String constName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int constTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int constTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct constType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				parser.globalConstCnt++;
				Obj o = Tab.find(constName);
	 			if (o == Tab.noObj) {
	 				o = Tab.insert(Obj.Con, constName, parser.type);
	 				parser.report_info("Constant '" + constName + "' declaration at row " + constNameleft, null);
	 			} else {
	 				parser.report_error("Semantics error at row " + constNameleft + " - multiple definition of '" + constName + "'", null);
	 			}
	 			
	 			if (!o.getType().compatibleWith(constType))
	 				parser.report_error("Semantics error at row " + constNameleft + " - incompatible types", null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Constant",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ConstList ::= Constant 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ConstList ::= error COMMA Constant 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // ConstList ::= ConstList COMMA Constant 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ConstDecl ::= CONST error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ConstDecl ::= CONST VarType error SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.report_debug("Successful error recovery - constant definition"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ConstDecl ::= CONST VarType ConstList SEMI_COMMA 
            {
              Object RESULT =null;
		 parser.type = Tab.noType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // MethodDeclList ::= MethodDeclList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // LocalVarDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // LocalVarDeclList ::= LocalVarDeclList LocalVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // List ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // List ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // List ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("List",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Lists ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Lists",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // Lists ::= Lists List 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Lists",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgramName ::= IDENT 
            {
              Obj RESULT =null;
		int progNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int progNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String progName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
	RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
	Tab.openScope();

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgramName",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROGRAM ProgramName Lists LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
	Tab.chainLocalSymbols(p);
	Tab.closeScope(); 

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

