package compiler;

import java_cup.runtime.*;
import java.util.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.DumpSymbolTableVisitor;
import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;
import rs.etf.pp1.mj.runtime.Code;

parser code {:

	public static final Struct stringType = new Struct(Struct.Array, new Struct(Struct.Char, Tab.noType));
	public static final Struct boolType = new Struct(Struct.Int);
	public static final String boolTrue = "true", boolFalse = "false", classThis = "this";

	Logger log = Logger.getLogger(getClass());
	Map<Struct, ArrayList<Struct>> inheritanceTable = new LinkedHashMap<Struct, ArrayList<Struct>>();
	Struct type;
	public boolean semError = false;
	
	boolean inClass = false,
			inMain = false,
			method = false,
			attrDef = false;
	
	// nivo A
	int globalVarCnt = 0,			//	definicije glob prom
		localVarCnt = 0,			//	definicije lokalnih prom u mainu
		globalConstCnt = 0,			//	definicije glob konstanti
		globalArrayCnt = 0;			// 	deklaracije glob nizova
		
	// nivo B
	int functionCnt = 0,			// definicije funkcija u glavnom programu
		blockCnt = 0,				//	blokovi naredbi
		callCnt = 0,				//	pozivi funkcija u main metodi
		formParCnt = 0;				//	deklaracije form argumenata funkcija
		
	// nivo C
	int nestedClassCnt = 0,			//	definicije unutr klasa
		nestedClassMethodCnt = 0,	//	definicije metoda unutr klasa
		nestedClassAttrCnt = 0;		//	deklaracije polja unutr klasa 
   
    
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal syntax error - ", cur_token);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void report_error(String message, Object info) {
    	semError = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol) {
            msg.append (" at row ").append(((Symbol)info).left);
            msg.append (" - unrecognized symbol '").append(((Symbol)info).value + "'");
        }
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at row ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
    public void report_debug(String message) {
    	StringBuilder msg = new StringBuilder(message); 
        log.debug(msg.toString());
    }
    
    public String objToString(Obj o) {
    	SymbolTableVisitor stv = new DumpSymbolTableVisitor();
    	
    	stv.visitObjNode(o);
    	return stv.getOutput();
    }
    
     public boolean assignableTo(Obj dst, Struct src) {
    	Struct dstType = dst.getType();
    	
    	if (src.assignableTo(dstType))
    		return true;
    	/*
		if (dstType.getKind() == Struct.Array && dstType.getElemType().equals(Tab.charType) && src.equals(stringType))
			return true;
		*/
		if (dstType.getKind() == Struct.Class && src.getKind() == Struct.Class)
			if (inheritanceTable.containsKey(src))
				if (inheritanceTable.get(src).contains(dstType))
					return true;
	
		return false;
	}
	
	// NIVO B
	public void stringLiteral(String s) {
		Code.loadConst(s.length() - 2 + 1); // n
		Code.put(Code.newarray);
		Code.put(0);
		
		int i = 0;
		for (; i < s.length() - 2; i++) {
			Code.put(Code.dup);
			Code.loadConst(i);
			Code.loadConst(s.charAt(i+1));
			Code.put(Code.bastore);
		}
		
		// znak za '/0'
		Code.put(Code.dup);
		Code.loadConst(i);
		Code.loadConst(0);
		Code.put(Code.bastore);
	}
	
	// NIVO B
	public void checkCond(int or) {
		Code.put(Code.dup2);
		//	| left right left right
		Code.putFalseJump(Code.ne, 0);	// ako su isti idi na else
		int p = Code.pc - 2;
		
		// THEN
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.loadConst(or);			// ako su razliciti onda je sigurno false
		Code.putJump(0);
		int p2 = Code.pc - 2;
		Code.fixup(p);
		
		// ELSE
		Code.put(Code.pop);
		Code.loadConst(1);
		Code.putFalseJump(Code.eq, 0);	//ako je 0 idi na else
		p = Code.pc - 2;
		Code.loadConst(1);			// ako je 1 onda je true
		Code.putJump(0);
		int p3 = Code.pc - 2;
		Code.fixup(p);
		
		Code.loadConst(0);			// ako je 0 onda je false
		Code.fixup(p2);
		Code.fixup(p3);
	}
	
	// NIVO B
	public void concat() {
		Code.put(Code.dup);	// dupliraj adresu prvog
		Code.put(Code.arraylength);
		
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null) 
		//log.info(s.toString() + " " + s.value.toString());
	return s;
:}

init with {:
	Tab.init(); // Universe scope
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "string", stringType));
	Tab.currentScope().getLocals().insertKey(new Obj(Obj.Type, "bool", boolType));
:}

action code {:
	int constValue = 0;
	ArrayList<String> constStrings = new ArrayList<String> ();
	Obj currentMethod = null;
	Obj currentClass = null;
	Struct superClass = null;
	Obj currentDesignator = null;
	Obj currentCall = null;
	Stack<Obj> funcCalls = new Stack<Obj> ();
	Iterator<Obj> iterator = null;
	Stack<Iterator<Obj>> iterators = new Stack<Iterator<Obj>> ();
	int pos = 0;
	Stack<Integer> positions = new Stack<Integer> ();
	boolean returnFound = false;
	int fpPos = 0, actPars = 0;
	boolean isVoid = false;
	boolean inWhile = false;
	
	// NIVO B
	// if else patch stack
	Stack<Integer> patch = new Stack<Integer> ();
	Stack<Integer> patch2 = new Stack<Integer> ();
	Stack<Boolean> cond = new Stack<Boolean> ();
:}

/**********************************************************************************************************/

/* Keywords */
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, WHILE, EXTENDS ;
	
/* Identifiers */
terminal String IDENT ;
	
/* Constants */
terminal Integer NUMBER ;
terminal Character CHAR ;
terminal Boolean BOOL ;
terminal String STRING ;
	
/* Operators */
terminal String PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, GRE, GREQ, LESS, LEQ, AND, OR, EQUALS, INC, DEC, SEMI_COMMA, COMMA, STOP, 
		 LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE ;

/* Non terminals */
non terminal Program, Lists, List ;
non terminal ConstDecl, ConstList, Constant, VarType ;
non terminal VarDecl, VarList, Variable ;
non terminal LocalVarDeclList, LocalVarDecl, LocalVarList, LocalVariable ;
non terminal ClassDecl, Extends, Methods ;
non terminal MethodDeclList, MethodDecl, FormParsOpt, FormPars, FormPar, StatementList, Statement ;
non terminal Matched, Unmatched, MatchedIfStatement, UnmatchedIfStatement, IfTerm ;
non terminal MatchedWhileStatement, UnmatchedWhileStatement, BreakStatement, WhileTerm ;
non terminal ExprStatement, ReturnStatement, ReadStatement, PrintStatement ;
non terminal Integer Relop, Addop, Mulop, IncDec, NumberOpt ;

/* Semantics */
non terminal Obj ProgramName, Designator, DesignatorList ;
non terminal Struct ConstType, Type, ReturnType, Factor, Expr, Term, Function, ActPars, ConditionCheck, Condition, CondTerm, CondFact ;
non terminal Boolean BracketsOpt ;
non terminal Assignment, SideEffect, FunctionCall ;

non terminal IfMatched ;


/**********************************************************************************************************/

Program ::= PROGRAM ProgramName:p Lists LBRACE MethodDeclList RBRACE:dummy
		{:
			// NIVO A
			Code.dataSize = Tab.currentScope().getnVars();
			
			Tab.chainLocalSymbols(p);
			Obj o = Tab.find("main");
			if (o == Tab.noObj || o.getKind() != Obj.Meth)
				parser.report_error("Semantics error at row " + dummyleft + " - program missing 'main' function", null);
			Tab.closeScope();
			
		:}
;
ProgramName ::= IDENT:progName 
			{:
				RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
				Tab.openScope();
				// parser.report_info("PARSING the program '" + progName + "' at row " + progNameleft, null);
				
			:}
;



Lists ::= Lists List |    ;
List ::= ConstDecl | VarDecl | ClassDecl ;
LocalVarDeclList ::= LocalVarDeclList LocalVarDecl |    ;
MethodDeclList ::= MethodDeclList MethodDecl |    ;



ConstType ::= NUMBER:val
			{: RESULT = Tab.intType; constValue = val; :}
			| CHAR:val
			{: RESULT = Tab.charType; constValue = val; :}
			| BOOL:val
			{: 
				RESULT = parser.boolType; 
				if (val.booleanValue())
					constValue = 1; 
				else
					constValue = 0;
			:}
			| STRING:val 
			{: 
				RESULT = parser.stringType; 
				constStrings.add(val);
				constValue = constStrings.size() - 1; 
			:}
;
VarType ::= Type:type
 		{: parser.type = type; :}
 ;
Type ::= IDENT:typeName 
	{:	
		Obj typeNode = Tab.find(typeName);
		if (typeNode == Tab.noObj) {
			parser.report_error("Semantics error at row " + typeNameleft + " - type '" + typeName + "' not found in symbol table", null);
			RESULT = Tab.noType;
		}
		else {
			if (Obj.Type == typeNode.getKind()) {
				RESULT = typeNode.getType();
			}
			else {
				parser.report_error("Semantics error at row " + typeNameleft + " - name '" + typeName + "' doesn't represent a type", null);
				RESULT = Tab.noType;
			}
		}
	:}
;



ConstDecl ::= CONST VarType ConstList SEMI_COMMA
			{: parser.type = Tab.noType; :} 
			| CONST VarType error SEMI_COMMA
			{: parser.report_debug("Successful error recovery - constant definition"); :}
			| CONST error SEMI_COMMA
			{: parser.report_debug("Successful error recovery - constant definition"); :}
;
ConstList ::= ConstList COMMA Constant 
			| error COMMA Constant
			{: parser.report_debug("Successful error recovery - constant definition"); :}
			| Constant
;
Constant ::= IDENT:constName EQUALS ConstType:constType 
			{: 
				parser.globalConstCnt++;
				Obj o = Tab.find(constName);
	 			if (o == Tab.noObj) {
	 				o = Tab.insert(Obj.Con, constName, parser.type);
	 				o.setAdr(constValue);
	 				constValue = 0;
	 				// parser.report_info("Constant '" + constName + "' declaration at row " + constNameleft, null);
	 				
	 				// NIVO B
	 				if (o.getType() == parser.stringType) {
	 					
					}
	 			} else {
	 				parser.report_error("Semantics error at row " + constNameleft + " - multiple definition of '" + constName + "'", null);
	 			}
	 			
	 			if (!o.getType().compatibleWith(constType))
	 				parser.report_error("Semantics error at row " + constNameleft + " - incompatible types", null);
			:} 
		  	|  IDENT EQUALS error
		    {: parser.report_debug("Successful error recovery - value assignment (constant)"); :}
;
		    
		    
		    
VarDecl ::= VarType VarList SEMI_COMMA
		{: parser.type = Tab.noType; :}
		| 	VarType error SEMI_COMMA
		{: parser.report_debug("Successful error recovery - global variable definition"); :}
;
VarList ::= VarList COMMA Variable 
		| 	error COMMA Variable
		{: parser.report_debug("Successful error recovery - global variable definition"); :}
		|	Variable 
;
Variable ::= IDENT:varName BracketsOpt:brack
			{: 	
	 			Obj o = Tab.find(varName);
	 			if (o == Tab.noObj) {
	 				if (!brack.booleanValue())
		 				Tab.insert(Obj.Var, varName, parser.type);
	 				else
	 					Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
	 				// parser.report_info("Global variable '" + varName + "' declaration at row " + varNameleft, null);	
	 			} else {
	 				parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of '" + varName + "'", null);
	 			}
			:}
;
			
			
			
LocalVarDecl ::= Type:type
			 {: parser.type = type; :}
			  LocalVarList SEMI_COMMA
			 {: parser.type = Tab.noType; :} 
			 |   Type error SEMI_COMMA
			 {: 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration"); 
			 :}
			 |	 Type error
			 {: 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.report_debug("Successful error recovery - local variable definition");
				else
				 	parser.report_debug("Successful error recovery - class attribute declaration");
			 :}
;
LocalVarList ::= LocalVarList COMMA LocalVariable 
			 |	 LocalVariable 
;
LocalVariable ::= IDENT:varName BracketsOpt:brack
			{: 	
				// brojimo samo lokalne u main funkciji
				if (parser.inMain)
					parser.localVarCnt++;
				else if (parser.inClass && parser.attrDef) 
					parser.nestedClassAttrCnt++;
	 			
	 				if (parser.attrDef) {
	 					Obj o = Tab.currentScope().findSymbol(varName);
	 					if (o == null) {
		 					if (!brack.booleanValue())
			 					Tab.insert(Obj.Fld, varName, parser.type);
		 					else
		 						Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, parser.type));
		 					// parser.report_info("Class attribute '" + varName + "' declaration at row " + varNameleft, null);
	 					} else {
	 						if ((superClass != null) && (superClass.getMembers().searchKey(varName) != null)) {
	 							int adr = o.getAdr();
	 							Tab.currentScope().getLocals().deleteKey(varName);
	 							if (!brack.booleanValue())
				 					o = Tab.insert(Obj.Fld, varName, parser.type);
			 					else
			 						o = Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, parser.type));
	 							o.setAdr(adr);
	 							// parser.report_info("Class attribute '" + varName + "' redefinition at row " + varNameleft, null);
	 						} else
	 							parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of a class attribute '" + varName + "'", null);				
	 					}
	 				} else {
	 					Obj o = Tab.currentScope().findSymbol(varName);
 						if (o == null) {
		 					if (!brack.booleanValue())
			 					Tab.insert(Obj.Var, varName, parser.type);
		 					else
		 						Tab.insert(Obj.Var, varName, new Struct(Struct.Array, parser.type));
		 					// parser.report_info("Local variable '" + varName + "' declaration at row " + varNameleft, null);
		 				} else {
		 					parser.report_error("Semantics error at row " + varNameleft + " - multiple definition of a local variable '" + varName + "'", null);
		 				}
	 				}	
	 			
			:}
;			
BracketsOpt ::= LBRACKET RBRACKET 
			 {: 
			 	RESULT = new Boolean(true);
			 	if (!parser.method && !parser.inClass) 
			 		parser.globalArrayCnt++; 
			 :} 
			 |     
			 {: 
			 	RESULT = new Boolean(false);
			   	if (!parser.method && !parser.inClass) 
			   		parser.globalVarCnt++; 
			 :} 
;



ClassDecl ::= CLASS IDENT:className
			  {: 
			  	parser.inClass = true;
			  	
			  	Obj o = Tab.find(className);
			  	if (o == Tab.noObj) {
	 				currentClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
	 				// parser.report_info("Class '" + className + "' definition at row " + classNameleft, null);
	 			} else {
	 				currentClass = o;
	 				parser.report_error("Semantics error at row " + classNameleft + " - multiple definition of a class '" + className + "'", null);
	 			}
	 			Tab.openScope();		  		
			  :} 
			  Extends LBRACE 
			  {: 
			  	parser.attrDef = true;
			  	if (superClass != null) {
			  		ArrayList<Struct> list = new ArrayList<Struct> ();
					list.add(superClass);
					if (parser.inheritanceTable.containsKey(superClass)) {
						list.addAll(parser.inheritanceTable.get(superClass));
					}
					parser.inheritanceTable.put(currentClass.getType(), list);
				}
			  :}
			  LocalVarDeclList 
			  {: 
			  	parser.attrDef = false; 
			  	currentClass.getType().setMembers(Tab.currentScope().getLocals());
			  	if (superClass != null) {
			  		Iterator<Obj> exIter = superClass.getMembers().symbols().iterator();
					Obj meth = null;
					Obj o = null;
					while (exIter.hasNext()) {
						meth = exIter.next();
						if (meth.getKind() == Obj.Meth) {
			 				o = Tab.insert(Obj.Meth, meth.getName(), meth.getType());
			 				Tab.openScope();
			 				Iterator<Obj> methIter = meth.getLocalSymbols().iterator();
			 				int i = 0;
			 				while (methIter.hasNext()) {
			 					Obj par = methIter.next();
			 					if (par.getType().getKind() != Struct.Array)
				 					par = Tab.insert(Obj.Var, par.getName(), par.getType());
				 				else
				 					par = Tab.insert(Obj.Var, par.getName(), new Struct(Struct.Array, par.getType().getElemType()));
				 				if (i < meth.getLevel())
				 					par.setFpPos(i++);		
			 				}
			 				Tab.chainLocalSymbols(o);
			 				Tab.closeScope();
			 				o.setLevel(i);
						}
					}
			  	}
			  :}
			  Methods RBRACE 
			  {: 
			  	parser.inClass = false; 
			  	parser.nestedClassCnt++;
			  	Tab.chainLocalSymbols(currentClass.getType());
			   	Tab.closeScope();
			   	currentClass = null;
			   	superClass = null;
			  :} 
;
Extends ::= EXTENDS Type:outerClass
			{:
				if (!(outerClass.getKind() == Struct.Class))
					parser.report_error("Semantics error at row " + outerClassleft + " - outer class must be of a class type", null);
				else if (outerClass == currentClass.getType())
					parser.report_error("Semantics error at row " + outerClassleft + " - class cannot inherit itself", null);
				else {
					// parser.report_info("Class inheritance at row " + outerClassleft, null);
					superClass = outerClass;
					Iterator<Obj> exIter = superClass.getMembers().symbols().iterator();
					Obj o = null;
					for (int i = 0; i < superClass.getNumberOfFields(); i++) {
						o = exIter.next();
						if (o.getKind() == Obj.Fld) {
							if (o.getType().getKind() != Struct.Array)
				 				Tab.insert(o.getKind(), o.getName(), o.getType());
			 				else
			 					Tab.insert(o.getKind(), o.getName(), new Struct(Struct.Array, o.getType().getElemType()));
						}
					}
				}
			:} 
			|  EXTENDS error
			{: parser.report_debug("Successful error recovery - class inheritance"); :}
			|    
;
Methods ::= LBRACE MethodDeclList RBRACE
		|
;



MethodDecl ::= ReturnType:retType IDENT:methName
			   {: 
			   	  parser.method = true; 
			   	  if (!parser.inClass && methName.equals("main")) 
			   	  	parser.inMain = true;
			   	  
			   	  Obj o = Tab.currentScope().findSymbol(methName);
				  if (o == null) {
		 				currentMethod = Tab.insert(Obj.Meth, methName, retType);
		 				// parser.report_info("Function '" + methName + "' definition at row " + methNameleft, null);
		 		  } else {
		 		  		currentMethod = o;
		 		  		if (!((superClass != null) && (superClass.getMembers().searchKey(methName) != null)))
		 					parser.report_error("Semantics error at row " + methNameleft + " - multiple definition of a function '" + methName + "'", null);
		 		  		else {
		 		  			// parser.report_info("Class method '" + methName + "' redefinition at row " + methNameleft, null);
		 		  		}
		 		  }	 
			   	  Tab.openScope();
			   	  
			   	  if (parser.inMain && !isVoid)
			   	  	parser.report_error("Semantics error at row " + methNameleft + " - function '" + methName + "' must be VOID", null);  	   
			   :}
			   LPAREN FormParsOpt RPAREN LocalVarDeclList LBRACE 
			   {:
			   	  // NIVO A
			   	  currentMethod.setLevel(fpPos);
			   	  currentMethod.setAdr(Code.pc);
			   	  if (parser.inMain) {
			   		Code.mainPc = currentMethod.getAdr();
			   	  }
			   	  Code.put(Code.enter);
			   	  Code.put(currentMethod.getLevel());
			   	  Code.put(Tab.currentScope().getnVars());
			   :}
			   StatementList RBRACE:dummy 
			   {: 
			   	  if (parser.inMain && fpPos > 0)
					parser.report_error("Semantics error at row " + methNameleft + " - 'main' function cannot have parameters", null);
					
			   	  // da li brojimo i main u funkcije
			   	  parser.method = false;
			   	  parser.blockCnt++;
			   	  if (!parser.inClass) 
			   	  	parser.functionCnt++;
			   	  else 
			   	  	parser.nestedClassMethodCnt++;
			   	  if (parser.inMain) 
			   	  	parser.inMain = false;
			   	  	
			   	  if (!returnFound && !isVoid)
			   	 	parser.report_error("Semantics error at row " + dummyleft + " - function '" + methName + "' missing 'return' statement", null);
			   	  
			   	  Tab.chainLocalSymbols(currentMethod);
			   	  Tab.closeScope();
			   	  
			   	  // NIVO A
			   	  if (isVoid) {
				   	  Code.put(Code.exit);
					  Code.put(Code.return_);
				  } else {
				  // generise trap ako se zaobidje return
					  Code.put(Code.trap); 
					  Code.put(1);
				  }

			   	  returnFound = isVoid = false;
				  currentMethod = null;
				  fpPos = 0;
			   :}
;
ReturnType ::= Type:type
			{: isVoid = (type == Tab.noType); RESULT = type; :} 
			| VOID 
			{: isVoid = true; RESULT = Tab.noType; :}
;
FormParsOpt ::= FormPars |    ;
FormPars ::= FormPars COMMA FormPar
		 |	 error COMMA FormPar
		 {: parser.report_debug("Successful error recovery - formal parameter declaration"); :}
		 | 	 FormPar 
;
FormPar ::= Type:type IDENT:parName BracketsOpt:brack 
			{: 					
				parser.formParCnt++;
				
				Obj o = Tab.currentScope().findSymbol(parName);
	 			if (o == null) {
	 				if (!brack.booleanValue())
	 					o = Tab.insert(Obj.Var, parName, type);
	 				else
	 					o = Tab.insert(Obj.Var, parName, new Struct(Struct.Array, type));
	 				o.setFpPos(fpPos);
	 				fpPos++;
	 				// parser.report_info("Formal parameter '" + parName + "' declaration at row " + parNameleft, null);
	 			} else {
	 				parser.report_error("Semantics error at row " + parNameleft + " - multiple definition of '" + parName + "'", null);
	 			} 
			:}
			|	Type error
			{: parser.report_debug("Successful error recovery - formal parameter declaration"); :}
;
StatementList ::= StatementList Statement |    ;



Statement ::= Matched | Unmatched ;
Unmatched ::= UnmatchedIfStatement
			| UnmatchedWhileStatement ;
Matched ::= ExprStatement
			| MatchedIfStatement
			| MatchedWhileStatement
			| BreakStatement
			| ReturnStatement
			| ReadStatement
			| PrintStatement 
			| LBRACE StatementList RBRACE 
			{: parser.blockCnt++; :}
;
	
ExprStatement ::= Assignment
				| SideEffect
				| FunctionCall
;
Assignment ::= Designator:desig EQUALS Expr:expr SEMI_COMMA
			{:	
				// NIVO A		
				if (desig != null) {
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be a variable", null);
						desig = Tab.noObj;
					}
					// menjano
	 				if (!parser.assignableTo(desig, expr))
	 					parser.report_error("Semantics error at row " + desigleft + " - incompatible types", null);
	 				else
	 					Code.store(desig);	 	
				} // else
					// parser.report_error("Desig je null", null);
						
			:}
			|  Designator EQUALS error SEMI_COMMA
			{: parser.report_debug("Successful error recovery - value assignment"); :}
;
SideEffect ::= Designator:desig IncDec:op SEMI_COMMA
			{:
				// NIVO A
				if (desig != null) {
					if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
						parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
					} else {
						if (!desig.getType().equals(Tab.intType))
							parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be an lvalue", null);
						else {
							Code.put(Code.inc);
							Code.put(desig.getAdr()); 
							//Code.load(desig);
							if (op == Code.inc) {
								Code.put(1);
							} else {
								Code.put(-1);
							}
						}
					}
				} // else
					// parser.report_error("Desig je null", null);
			:}
;
// NIVO A
IncDec ::= INC
		{: RESULT = Code.inc; :}
		| DEC 
		{: RESULT = -1; :}
;
FunctionCall ::= Function SEMI_COMMA ;
Function ::= Designator:desig LPAREN 
		 {:
		 	if (parser.inMain) 
				parser.callCnt++;
				
		 	if (desig != null) {
		 		if (desig.getKind() != Obj.Meth)
		 			parser.report_error("Semantics error at row " + desigleft + " - variable must be a global function or a class method", null);
		 		else {
		 			if (currentCall != null) {
							funcCalls.push(currentCall);
							iterators.push(iterator);
							positions.push(pos);
					}
					currentCall = desig;
					iterator = currentCall.getLocalSymbols().iterator();
					pos = 0;
					if (currentCall.getLevel() <= 0)
			 			parser.report_error("Semantics error at row " + desigleft + " - function doesn't need parameters", null);					
				}
		 	} // else
		 		// parser.report_error("Desig je null", null);
		 	
		 :}
		 ActPars RPAREN:dummy
		 {:
			RESULT = Tab.noType;
			if (currentCall != null) {
				RESULT = currentCall.getType();
				if (currentCall.getLevel() > pos)
			 			parser.report_error("Semantics error at row " + dummyleft + " - function '" + currentCall.getName() + "' missing parameters", null);										
				// NIVO B
				int dest_adr = currentCall.getAdr() - Code.pc; // relativna adresa
				Code.put(Code.call); 
				Code.put2(dest_adr);
				
				if (funcCalls.size() > 0) {
					currentCall = funcCalls.pop();
					iterator = iterators.pop();
					pos = positions.pop();
				} else {
					currentCall = null;
					iterator = null;
					pos = 0;
				}
		 	} // else
		 		// parser.report_error("Current call je null", null);
		  :}
		  |  Designator:desig LPAREN RPAREN
		  {:
			 if (parser.inMain) 
					parser.callCnt++;

				RESULT = Tab.noType;
				if (desig != null) {
			 		if (desig.getKind() != Obj.Meth)
			 			parser.report_error("Semantics error at row " + desigleft + " - variable must be a global function or a class method", null);
			 		else {
							if (desig.getLevel() > 0)
								parser.report_error("Semantics error at row " + desigleft + " - function '" + desig.getName() + "' missing parameters", null);
							else {
								RESULT = desig.getType();
								// NIVO B
								int dest_adr = desig.getAdr() - Code.pc; // relativna adresa
								Code.put(Code.call); 
								Code.put2(dest_adr);
							}
						}
			 	} // else
			 		// parser.report_error("Desig je null", null);
		  :}
		  |	Designator:desig LPAREN error RPAREN
		  {: parser.report_debug("Successful error recovery - actual parameters list"); :}
;
ActPars ::= Expr:expr
		{: 
			RESULT = Tab.noType;
			if (currentCall != null) {
				if (currentCall.getLevel() > pos) {
					if (currentCall.getName().equals("len")) {
						if (expr.getKind() != Struct.Array)
							parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + (pos+1) + ". parameter", null);
						else
							RESULT = expr;
					} else {
						if (!iterator.next().getType().compatibleWith(expr))
							parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + (pos+1) + ". parameter", null);
						else
							RESULT = expr;
					}
					pos++;
				} else 
					parser.report_error("Semantics error at row " + exprleft + " - number of parameters doesn't match", null);	
			} // else 
				// parser.report_error("Current call je null", null);	
		:}
;
ActPars ::= ActPars:actPars COMMA Expr:expr 
		{:
			RESULT = Tab.noType;
			if (currentCall != null) {
				if (currentCall.getLevel() > pos) {
					if (!iterator.next().getType().compatibleWith(expr))
						parser.report_error("Semantics error at row " + exprleft + " - incompatible types of " + (pos+1) + ". parameter", null);
					else
						RESULT = expr;
					pos++;
				} else 
					parser.report_error("Semantics error at row " + exprleft + " - number of parameters doesn't match", null);	
			} // else
				// parser.report_error("Current call je null", null);	
		:}
; 



// NIVO B
MatchedIfStatement ::= IfMatched Matched 
					 {: if (cond.pop().booleanValue()) Code.fixup(patch2.pop()); :} 
;
UnmatchedIfStatement ::= IfTerm LPAREN Condition RPAREN Statement 
					 {: if (cond.pop().booleanValue()) Code.fixup(patch.pop()); :}
					 | IfMatched Unmatched 
					 {: if (cond.pop().booleanValue()) Code.fixup(patch2.pop()); :} 
;
IfMatched ::= IfTerm LPAREN Condition RPAREN Matched ELSE 
		  {:
		  		if (cond.peek().booleanValue()) {
			  		Code.putJump(0);
					patch2.push(new Integer(Code.pc - 2));
					Code.fixup(patch.pop());
				}
		  :} 
;
IfTerm ::= IF 
		{:
		
		:}
;



MatchedWhileStatement ::= WhileTerm LPAREN Condition RPAREN Matched 
						{: inWhile = false; :}
;
UnmatchedWhileStatement ::= WhileTerm LPAREN Condition RPAREN Unmatched 
						{: inWhile = false; :}
;
WhileTerm ::= WHILE {: inWhile = true; :} ;
BreakStatement ::= BREAK:dummy SEMI_COMMA 
				{:
					if (!inWhile)
						parser.report_error("Semantics error at row " + dummyleft + " - 'break' statement can only be used inside a while loop", null);
				:}
;



// NIVO B
Condition ::= ConditionCheck:result 
			{:
				if (!result.equals(parser.boolType)) {
					cond.push(new Boolean(false));
					parser.report_error("Semantics error at row " + resultleft + " - expression must be a boolean value", null);				
				} else {
					Code.loadConst(1);
					Code.putFalseJump(Code.eq, 0);
					patch.push(new Integer(Code.pc - 2));
					cond.push(new Boolean(true));
				}
			:}
			| error
			{: parser.report_debug("Successful error recovery - condition of an if/while construction"); :}
;
ConditionCheck ::= ConditionCheck:typeL OR CondTerm:typeR
			  {:
			  	RESULT = Tab.noType;
				if (typeL.equals(parser.boolType) && typeR.equals(parser.boolType)) {
					// treba da proveris prvo da li su razliciti
					// ako jesu onda je sigurno true
					// ako su isti treba da proveris vrednost bar jednog da l' je 1
					parser.checkCond(1);
								
					RESULT = parser.boolType;
				}
			  :}
			  | CondTerm:type
			  {:
			  	RESULT = Tab.noType;
				if (type.equals(parser.boolType))
					RESULT = parser.boolType;
				// vec ucitano na stek preko CondTerm
			  :} 		  
;
CondTerm ::= CondFact:type
		{: RESULT = type; // vec ucitano na stek preko CondFact :}
;
CondTerm ::= CondTerm:typeL AND CondFact:typeR 
		{:
			RESULT = Tab.noType;
			if (typeL.equals(parser.boolType) && typeR.equals(parser.boolType)) {
				// treba da proveris prvo da li su razliciti
				// ako jesu onda je sigurno false
				// ako su isti treba da proveris vrednost bar jednog da l' je 1				
				parser.checkCond(0);
				
				RESULT = parser.boolType;
			}
		:}
;
CondFact ::= Expr:expr
		{: RESULT = expr; // vec ucitano na stek preko expr :}
;
CondFact ::= Expr:typeL Relop:op Expr:typeR
		{:
			RESULT = Tab.noType;
			if (typeL.getKind() == Struct.Array || typeR.getKind() == Struct.Array || typeL.getKind() == Struct.Class || typeR.getKind() == Struct.Class) {
				if (op != Code.ne && op != Code.eq)
					parser.report_error("Semantics error at row " + typeLleft + " - operator in condition expression is not allowed for class/array types", null);
				else {
					if (!typeL.compatibleWith(typeR))
						parser.report_error("Semantics error at row " + typeLleft + " - incompatible types", null);
					else {
						RESULT = parser.boolType;
					}
				}
			}
			else {
				if (!typeL.compatibleWith(typeR))
					parser.report_error("Semantics error at row " + typeLleft + " - incompatible types", null);
				else {
					// NIVO B
					Code.putFalseJump(op, 0);	// ako je netacno idi na else
					int p = Code.pc - 2;
					Code.loadConst(1);			// ako je tacno postavi 1 na stek
					Code.putJump(0);
					int p2 = Code.pc - 2;
					Code.fixup(p);
					Code.loadConst(0);			// ako je netacan uslov postavi 0 na stek
					Code.fixup(p2);
					
					RESULT = parser.boolType;
				}
			}		
		:}
;



// NIVO B
ReturnStatement ::= RETURN:dummy SEMI_COMMA 
				{:
					returnFound = true;
				 	Struct currMethType = currentMethod.getType();
				 	if (!isVoid) {
				 		parser.report_error("Semantics error at row " + dummyleft + " - function missing a return value", null);
				 	}
				 	/*
				 	Code.put(Code.exit);
					Code.put(Code.return_);
					*/  	 
			    :}
			    |	RETURN Expr:expr SEMI_COMMA
			    {:
			    	returnFound = true;
			    	Struct currMethType = currentMethod.getType();
			    	if (isVoid)
			    		parser.report_error("Semantics error at row " + exprleft + " - function does not need a return value", null);
			    	else if (!expr.compatibleWith(currMethType))
			    		parser.report_error("Semantics error at row " + exprleft + " - return types are not compatible", null);
			    	else {
			    		Code.put(Code.exit);
						Code.put(Code.return_);
					}
			    :}
;



// NIVO A
ReadStatement ::= READ LPAREN Designator:desig RPAREN SEMI_COMMA 
				{:					
					if (desig != null)
						if (desig.getKind() != Obj.Var && desig.getKind() != Obj.Fld && desig.getKind() != Obj.Elem) {
							parser.report_error("Semantics error at row " + desigleft + " - expression '" + desig.getName() + "' must be a variable", null);
						} else {
							if (desig.getType() != Tab.intType && desig.getType() != Tab.charType && desig.getType() != parser.boolType && desig.getType() != parser.stringType)
								parser.report_error("Semantics error at row " + desigleft + " - parameter must be an integer/character/boolean or a string value", null);							
							else {
								 if (desig.getType() == Tab.intType) {
							  	 	Code.put(Code.read);
							  	 }
							  	 if (desig.getType() == Tab.charType) {
							  	 	Code.put(Code.bread);	
							  	 }
							  	 // NIVO B
							  	 if (desig.getType() == parser.stringType) {
							  	 
							  	 }
							  	 Code.store(desig);
							}
						}
					// else
						// parser.report_error("Desig je null", null);
				:}
;



// NIVO A
PrintStatement ::= PRINT LPAREN Expr:expr NumberOpt:n RPAREN SEMI_COMMA 
				{:					
					if (expr != Tab.intType && expr != Tab.charType && expr != parser.boolType && expr != parser.stringType)
						parser.report_error("Semantics error at row " + exprleft + " - parameter must be an integer/character/boolean or a string value", null);							
					else {
						 if (expr == Tab.intType) {
						 	Code.loadConst((n.intValue() == -1 ? 5 : n.intValue()));
					  	 	Code.put(Code.print);
					  	 } 
					  	 if (expr == Tab.charType) {
					  	 	Code.loadConst((n.intValue() == -1 ? 1 : n.intValue()));
					  	 	Code.put(Code.bprint);
					  	 }
					  	 // NIVO B
					  	 if (expr == parser.stringType) {
					  	 // na steku imamo adresu niza
					  	 //		| adr
					  	 
						 }
					}
				:}
;
NumberOpt ::= COMMA NUMBER:n 
		  {: RESULT = n; :}
		  |  
		  {: RESULT = -1; :}
;



// NIVO A
Designator ::= DesignatorList:dlist 
			{: RESULT = dlist; :}
;			
DesignatorList ::= 	DesignatorList:cl STOP IDENT:field
				{:
					if (cl.getType().getKind() != Struct.Class) { 
                    	parser.report_error("Semantics error at row " + clleft + " - expected a class",null);
                    	RESULT = Tab.noObj;
                    } else {
                    	Obj o = cl.getType().getMembers().searchKey(field);
	                    if (o == null) {
	                    	o = Tab.noObj;
	                    	parser.report_error("Semantics error at row " + clleft + " - class attribute '" + field + "' doesn't exist",null);
	                    } else {
	                    	// moze da bude string ne moze da bude const string
	                    	Code.load(o);
	                    	// parser.report_info("Use of " + parser.objToString(o) + " at row " + clleft,null);
	                     }
	                    RESULT = o;
                    }     
				:}
				|	DesignatorList:array LBRACKET 
				{:
					RESULT = Tab.noObj;
					if (array.getType().getKind() != Struct.Array) { 
                    	parser.report_error("Semantics error at row " + arrayleft + " - expected an array",null);                  	
                    } else {
					 	Code.load(array); 		
                    }
				:}
				Expr:expr RBRACKET
				{:
					if (!expr.equals(Tab.intType))
					 	parser.report_error("Semantics error at row " + exprleft + " - array index must be an integer value", null);		 	
                    else if (array.getType().getKind() == Struct.Array) {                     	
                    	RESULT = new Obj (Obj.Elem, array.getName(), array.getType().getElemType());
                    }
				:}
				|	IDENT:ident
				{:	
					if (ident.equals(parser.classThis) && parser.inClass) {							 			
						RESULT = currentClass;
					} else {
						Obj o = Tab.find(ident);
						if (o != Tab.noObj) {
							// parser.report_info("Use of " + parser.objToString(o) + " at row " + identleft,null);		
						} else {
	                    	parser.report_error("Semantics error at row " + identleft + " - symbol '" + ident + "' not found",null);					
						}
						RESULT = o;
					}
				:}
				|	DesignatorList:array LBRACKET error RBRACKET
				{: 
					parser.report_debug("Successful error recovery - array indexing");
					
					if (array.getType().getKind() != Struct.Array) { 
                    	parser.report_error("Semantics error at row " + arrayleft + " - expected an array",null);
                    	RESULT = Tab.noObj;
                    } else {
                    	RESULT = new Obj (Obj.Elem, array.getName(), array.getType().getElemType());
                    } 
				:}
;
				


// NIVO A
Expr ::= Term:term
	{: RESULT = term; :}
;
Expr ::= MINUS Term:term 
	{:	
		// NIVO A
		RESULT = Tab.noType;
		if (!term.equals(Tab.intType))
				parser.report_error("Semantics error at row " + termleft + " - expression must be an integer value", null);
		else {
			Code.put(Code.neg);
			RESULT = term;
		}
	:}
;
Expr ::= Expr:expr Addop:addop 
	{:
		if (addop == Code.add) {
			if (expr.equals(parser.stringType)) {
				// NIVO B
				/*
				Code.put(Code.dup);
				Code.put(Code.dup);
				Code.put(Code.arraylength);
				Code.loadConst(1);
				Code.put(Code.sub);
				// | adr1 adr1 len1-1
				*/
				
				// 		| adr1 
				Code.put(Code.dup);
				Code.put(Code.arraylength);
				// 		| adr1 adr1 arraylenth
				RESULT = parser.stringType;
			}
		}
	:}
	Term:term
	{:
		RESULT = Tab.noType;
		if (expr.equals(Tab.intType) && term.equals(Tab.intType)) {
			// NIVO A
			Code.put(addop);
			RESULT = expr;
		}
		else if (addop == Code.add) {
			if (expr.equals(parser.stringType) && term.equals(parser.stringType)) {
				// NIVO B
				// na steku imas adresu jednog i adresu drugog
				/*
				// | adr1 adr1 len1-1 adr2
				Code.put(Code.bastore);
				*/
				
				/*
				// | adr1 len1 adr2 dup2
				Code.put(Code.dup2);
				Code.put(Code.arraylength);
				Code.put(Code.add);
				Code.put(Code.newarray);
				Code.put(0);
				// | adr1 len1 adr2 len1 adr2 arraylenth
				// | adr1 len1 adr2 len1 len2 add
				// | adr1 len1 adr2 lennew
				// | adr1 len1 adr2 adr3
				*/
				
				Code.put(Code.dup);
				Code.put(Code.arraylength);
				// 		| adr1 len1 adr2 len2
				RESULT = parser.stringType;
			} else
				parser.report_error("Semantics error at row " + exprleft + " - expressions must be integers or strings", null);
		} else
			parser.report_error("Semantics error at row " + exprleft + " - expressions must be integers", null);		
	:}
;



// NIVO A				
Term ::= Factor:factor
		{: RESULT = factor; :}
;
Term ::= Term:term Mulop:mulop Factor:factor
		{:
			RESULT = Tab.noType;
			if (!term.equals(Tab.intType) || !factor.equals(Tab.intType))
				parser.report_error("Semantics error at row " + factorleft + " - expression must be an integer value", null);
			else {
				Code.put(mulop);
				RESULT = term;
			}
		:}
;



// NIVO B
Factor::= Function:func 
		{: RESULT = func; :} 
;
// NIVO A
Factor ::= NEW Type:type LBRACKET Expr:expr RBRACKET
		{:			
			RESULT = Tab.noType;
		 	if (expr.equals(Tab.intType)) {
		 		Code.put(Code.newarray);
		 		Code.put((type == Tab.intType ? 1 : 0 )); 
		 		RESULT = new Struct(Struct.Array, type);
		 	} else
		 		parser.report_error("Semantics error at row " + exprleft + " - number of elements must be an integer value", null);		 	
		:}
;
Factor ::= NEW Type:type
		{:	
			RESULT = Tab.noType;
		 	if (type.getKind() != Struct.Class)
		 		parser.report_error("Semantics error " + typeleft + " - variable must be of a class type", null);
		 	else
		 		RESULT = type;
		:}
;
Factor ::= Designator:desig
		 {: 
		 	// NIVO B, proveravas je l const string, nakon ovoga na steku je njegova adresa
		 	if (desig.getKind() == Obj.Con && desig.getType() == parser.stringType) {
		 		parser.stringLiteral(constStrings.get(desig.getAdr()));	
		 	}
		 	// NIVO A
		 	else 
		 		Code.load(desig);
		 	RESULT = desig.getType(); 
		 :}
		 | NUMBER:n
		 {: 
		 	// NIVO A
		 	Obj o = Tab.insert(Obj.Con, "", Tab.intType);
			o.setAdr(n.intValue());
			Code.load(o);
			RESULT = Tab.intType; 
		 :}
		 | CHAR:c
		 {: 
		 	// NIVO A
		 	Obj o = Tab.insert(Obj.Con, "", Tab.charType);
			o.setAdr(c.charValue());
			Code.load(o);
			RESULT = Tab.charType;
		 :}
		 | BOOL:b
		 {: 
		 	// NIVO A
		 	Obj o = Tab.insert(Obj.Con, "", parser.boolType);
			o.setAdr((b.booleanValue() ? 1 : 0));
			Code.load(o);
		 	RESULT = parser.boolType; 
		 :}
		 | STRING:s
		 {: 
		 	// NIVO B
		 	// kada naidje na string konstantu "nekistring"
		 	parser.stringLiteral(s);
		 	RESULT = parser.stringType; 
		 :}
		 | LPAREN Expr:expr RPAREN 
		 {: 
		 	// NIVO A
		 	RESULT = expr; 
		 :}
;



// NIVO B
Relop ::= EQ {: RESULT = Code.eq; :}
		| NEQ {: RESULT = Code.ne; :}
		| GRE {: RESULT = Code.gt; :}
		| GREQ {: RESULT = Code.ge; :}
		| LESS {: RESULT = Code.lt; :}
		| LEQ {: RESULT = Code.le; :}
;
// NIVO A
Addop ::= PLUS {: RESULT = Code.add; :}
		 | MINUS {: RESULT = Code.sub; :}
;
// NIVO A
Mulop ::= MUL {: RESULT = Code.mul; :}
		| DIV {: RESULT = Code.div; :}
		| MOD {: RESULT = Code.rem; :}
;
