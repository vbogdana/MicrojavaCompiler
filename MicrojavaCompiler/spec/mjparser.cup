package compiler;

import java_cup.runtime.*;
//import java.io.*;
import org.apache.log4j.*;

parser code {:

	boolean inClass = false,
			inMain = false,
			method = false,
			attrDef = false;
	
	// nivo A
	int globalVarCnt = 0,			//	definicije glob prom
		localVarCnt = 0,			//	definicije lokalnih prom u mainu
		globalConstCnt = 0,			//	definicije glob konstanti
		globalArrayCnt = 0;			// 	deklaracije glob nizova
		
	// nivo B
	int functionCnt = 0,			// definicije funkcija u glavnom programu
		blockCnt = 0,				//	blokovi naredbi
		callCnt = 0,				//	pozivi funkcija u main metodi
		formParCnt = 0;				//	deklaracije form argumenata funkcija
		
	// nivo C
	int nestedClassCnt = 0,			//	definicije unutr klasa
		nestedClassMethodCnt = 0,	//	definicije metoda unutr klasa
		nestedClassAttrCnt = 0;		//	deklaracije polja unutr klasa
	
	Logger log = Logger.getLogger(getClass()); 
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal syntax error - ", cur_token);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at row ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/* Keywords */
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, WHILE, EXTENDS ;
	
/* Identifiers */
terminal String IDENT ;
	
/* Constants */
terminal Integer NUMBER ;
terminal Character CHAR ;
terminal Boolean BOOL ;
terminal String STRING ;
	
/* Operators */
terminal PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, GRE, GREQ, LESS, LEQ, AND, OR, EQUALS, INC, DEC, SEMI_COMMA, COMMA, STOP, 
		 LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE ;

/* End of file */	

/* Non terminals */
non terminal Program, Lists, List ;
non terminal ConstDecl, ConstList, Constant, ConstType, Type ;
non terminal VarDeclList, VarDecl, VarList, Variable, BracketsOpt, Brackets ;
non terminal ClassDecl, ExtendsOpt, Extends, MethodsOpt, Methods ;
non terminal MethodDeclList, MethodDecl, ReturnType, FormParsOpt, FormPars, FormPar, StatementList, Statement ;
non terminal Matched, Unmatched ;
non terminal ExprStatement, MatchedWhileStatement, UnmatchedWhileStatement, BreakStatement, ReturnStatement, ReadStatement, PrintStatement ;
non terminal Designator, DesignatorList, DesignatorDecl, AAA, ActParsOpt, ActPars, Expr, MinusOpt, AddopTermList, AddopTerm ;
non terminal Condition, CondTerm, CondFact, RelopExprOpt, RelopExpr ;
non terminal ExprOpt, NumberOpt ;
non terminal Term, MulopFactorList, MulopFactor, Factor, BracketsExprOpt, ParenActParsOpt ;
non terminal Relop, Addop, Mulop ;
non terminal LocalVarDeclList, LocalVarDecl, LocalVarList ;


Program ::= PROGRAM IDENT Lists LBRACE MethodDeclList RBRACE ;
Lists ::= Lists List |    ;
List ::= ConstDecl | VarDecl | ClassDecl ;

VarDeclList ::= VarDeclList VarDecl |    ;
LocalVarDeclList ::= LocalVarDeclList LocalVarDecl |    ;
MethodDeclList ::= MethodDeclList MethodDecl |    ;

ConstDecl ::= CONST Type ConstList SEMI_COMMA 
			| CONST Type error SEMI_COMMA
			{: parser.log.debug("Uspesan oporavak od greske pri definiciji konstante."); :}
			;
ConstList ::= ConstList COMMA Constant 
			| error COMMA Constant
			{: parser.log.debug("Uspesan oporavak od greske pri definiciji konstante."); :}
			| Constant
			;
Constant ::= IDENT EQUALS ConstType 
			 {: parser.globalConstCnt++; :} 
		  |  IDENT EQUALS error
		     {: parser.log.debug("Uspesan oporavak od greske pri dodeli vrednosti konstanti."); :}
		     ;
ConstType ::= NUMBER | CHAR | BOOL | STRING ;
Type ::= IDENT ;

VarDecl ::= Type VarList SEMI_COMMA 
		| 	Type error SEMI_COMMA
		{: 
			parser.log.debug("Uspesan oporavak od greske pri definiciji glob.promenljve.");
		:}
		;
LocalVarDecl ::= Type LocalVarList SEMI_COMMA 
			 |   Type error SEMI_COMMA
			 {: 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.log.debug("Uspesan oporavak od greske pri deklaraciji lok.promenljve.");
				else
				 	parser.log.debug("Uspesan oporavak od greske pri deklaraciji polja unutr.klase."); 
			 :}
			 |	 Type error
			 {: 
				// ovde gledamo sve lokalne promenljive, ne samo u mainu
				if (!parser.attrDef)
					parser.log.debug("Uspesan oporavak od greske pri deklaraciji lok.promenljve.");
				else
				 	parser.log.debug("Uspesan oporavak od greske pri deklaraciji polja unutr.klase.");
			 :}
			 ;
VarList ::= VarList COMMA Variable 
		| 	error COMMA Variable
		{: 
			parser.log.debug("Uspesan oporavak od greske pri definiciji glob.promenljve.");
		:}
		|	Variable 
		;
LocalVarList ::= LocalVarList COMMA Variable 
			 |	 Variable 
			 ;
Variable ::= IDENT BracketsOpt 
			{: 	
				if (parser.inClass && parser.attrDef) 
					parser.nestedClassAttrCnt++; 
			:}
			;
BracketsOpt ::= Brackets |     
				{: 
					// brojimo samo lokalne u main funkciji
					if (parser.inMain) 
						parser.localVarCnt++;
				   	else if (!parser.method && !parser.inClass) 
				   		parser.globalVarCnt++; 
				:} ;
Brackets ::= LBRACKET RBRACKET 
			 {: 
			 	// brojimo samo lokalne u main funkciji
			 	if (parser.inMain) 
			 		parser.localVarCnt++;
			 	else if (!parser.method && !parser.inClass) 
			 		parser.globalArrayCnt++; 
			 :} ;

ClassDecl ::= CLASS 
			  {: parser.inClass = true; :} 
			  IDENT ExtendsOpt LBRACE 
			  {: parser.attrDef = true; :}
			  LocalVarDeclList 
			  {: parser.attrDef = false; :}
			  MethodsOpt RBRACE 
			  {: 
			  	parser.inClass = false; 
			  	parser.nestedClassCnt++;
			  :} 
			  ;
ExtendsOpt ::= Extends 
			|  error
			{: parser.log.debug("Uspesan oporavak od greske pri deklaraciji prosirenja natklase."); :}
			|    ;
Extends ::= EXTENDS Type ;
MethodsOpt ::= Methods |    ;
Methods ::= LBRACE MethodDeclList RBRACE ;

MethodDecl ::= ReturnType IDENT:m LPAREN
			   {: 
			   	  parser.method = true; 
			   	  if (!parser.inClass && m.equals("main")) 
			   	  	parser.inMain = true; 
			   :}
			   FormParsOpt RPAREN LocalVarDeclList LBRACE StatementList RBRACE 
			   {: 
			   	  // da li brojimo i main u funkcije
			   	  parser.method = false;
			   	  parser.blockCnt++;
			   	  if (!parser.inClass) 
			   	  	parser.functionCnt++;
			   	  else 
			   	  	parser.nestedClassMethodCnt++;
			   	  if (parser.inMain) 
			   	  	parser.inMain = false;
			   :}
			 	;

ReturnType ::= Type | VOID ;
FormParsOpt ::= FormPars |    ;
FormPars ::= FormPars COMMA FormPar
		 |	 error COMMA FormPar
		 {: parser.log.debug("Uspesan oporavak od greske pri deklaraciji form.parametra."); :}
		 | 	 FormPar 
		 ;
FormPar ::= Type IDENT BracketsOpt 
			{: parser.formParCnt++; :}
		|	Type error
			{: parser.log.debug("Uspesan oporavak od greske pri deklaraciji form.parametra."); :}
			;
StatementList ::= StatementList Statement |    ;

Statement ::= Matched | Unmatched ;
Unmatched ::= IF LPAREN Condition RPAREN Statement
			  | IF LPAREN Condition RPAREN Matched ELSE Unmatched
			  | UnmatchedWhileStatement ;
Matched ::= ExprStatement
			| IF LPAREN Condition RPAREN Matched ELSE Matched
			| MatchedWhileStatement
			| BreakStatement
			| ReturnStatement
			| ReadStatement
			| PrintStatement 
			| LBRACE StatementList RBRACE 
			{: parser.blockCnt++; :}
			;
			
ExprStatement ::= Designator AAA SEMI_COMMA ;
Designator ::= IDENT DesignatorList ;
DesignatorList ::= DesignatorList DesignatorDecl |    ;
DesignatorDecl ::= STOP IDENT
				   | LBRACKET Expr RBRACKET 
				   | LBRACKET error RBRACKET
				   {: parser.log.debug("Uspesan oporavak od greske pri indeksiranju niza."); :}
				   ;
AAA ::= EQUALS Expr
		| EQUALS error
		{: parser.log.debug("Uspesan oporavak od greske pri dodeli vrednosti."); :}
		| INC 
		| DEC
		| LPAREN ActParsOpt RPAREN 
		{: 
			if (parser.inMain) 
				parser.callCnt++; 
		:}
		| LPAREN error RPAREN
		{: parser.log.debug("Uspesan oporavak od greske pri navodjenju liste parametara."); :}
		 ;
ActParsOpt ::= ActPars |    ;
ActPars ::= ActPars COMMA Expr | Expr ;

Expr ::= MinusOpt Term AddopTermList ;
MinusOpt ::= MINUS |    ;
AddopTermList ::= AddopTermList AddopTerm |    ;
AddopTerm ::= Addop Term ;

Condition ::= Condition OR CondTerm 
		  | CondTerm 
		  | error
		  {: parser.log.debug("Uspesan oporavak od greske pri logickom izrazu if/while konstrukcije."); :}
		  ;
CondTerm ::= CondTerm AND CondFact | CondFact ;
CondFact ::= Expr RelopExprOpt ;
RelopExprOpt ::= RelopExpr | ;
RelopExpr ::= Relop Expr ;
 
MatchedWhileStatement ::= WHILE LPAREN Condition RPAREN Matched ;
UnmatchedWhileStatement ::= WHILE LPAREN Condition RPAREN Unmatched ;

BreakStatement ::= BREAK SEMI_COMMA ;

ReturnStatement ::= RETURN ExprOpt SEMI_COMMA ;
ExprOpt ::= Expr |    ;

ReadStatement ::= READ LPAREN Designator RPAREN SEMI_COMMA ;

PrintStatement ::= PRINT LPAREN Expr NumberOpt RPAREN SEMI_COMMA ;
NumberOpt ::= COMMA NUMBER |    ;

Term ::= Factor MulopFactorList ;
MulopFactorList ::= MulopFactorList MulopFactor |    ;
MulopFactor ::= Mulop Factor ;
Factor ::= Designator ParenActParsOpt
		 | NUMBER
		 | CHAR
		 | STRING
		 | BOOL
		 | NEW Type BracketsExprOpt
		 | LPAREN Expr RPAREN 
		 ;
BracketsExprOpt ::= LBRACKET Expr RBRACKET |    ;
ParenActParsOpt ::= LPAREN ActParsOpt RPAREN
				{: 
					if (parser.inMain) 
						parser.callCnt++; 
				:}
				|	LPAREN error RPAREN
				{: parser.log.debug("Uspesan oporavak od greske pri navodjenju liste parametara."); :}
				|   ;

Relop ::= EQ | NEQ | GRE | GREQ | LESS | LEQ ;
Addop ::= PLUS | MINUS ;
Mulop ::= MUL | DIV | MOD ;
